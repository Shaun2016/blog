<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[kibana command]]></title>
    <url>%2F2018%2F08%2F08%2Fkibana-command%2F</url>
    <content type="text"><![CDATA[Kibana 命令查看Kibana启动结果 浏览器访问：http://ip:5601 进入 dev tools 模块，执行GET _cluster/health 返回值中 status: green：每个索引的 primary shard 和 replica shard 都是 active 的 yellow：每个索引的 primary shard 都是 active 的，但部分的 replica shard 不是 active 的 red：不是所有的索引都是 primary shard 都是 active 状态的 查看健康状态 GET _cat/health?v 索引创建索引1234567put /test_index&#123; "settings":&#123; "number_of_shards" : 2, "number_of_replicas" : 1 &#125;&#125; ES 默认创建索引会分配 5 个 primary shard，并为每个 primary shard 分配一个 replica shard。限制：如果磁盘空间不足 15% 时不分配 replica shard，不足 5% 时不分配 primary shard 可以设置 primary shard 的个数和每个 primary shard 的 replica shard 的个数 修改索引 索引一旦创建，primary shard 数量不可变化，可以改变replica shard 的数量： 1234PUT /test_index/_settings&#123; "number_of_replicas": 2&#125; 一个主分片和他的备份分片不会在一个节点上，对于一个主分片的多个备份分片也不会在一个节点上（很好理解——防止同时消失） 删除索引 DELETE /test_index,...，逗号分隔索引 查看索引 GET _cat/indices?v 查看分片 GET _cat/shards?v 123456789101112# 索引名 # 编号 # 主从 # 所在节点index shard prirep state docs store ip nodetest_index 3 r STARTED 0 261b 127.0.0.1 uwrhdxHtest_index 3 p STARTED 0 261b 127.0.0.1 9kTJ5Qetest_index 1 r STARTED 0 261b 127.0.0.1 uwrhdxHtest_index 1 p STARTED 0 261b 127.0.0.1 9kTJ5Qetest_index 2 p STARTED 0 261b 127.0.0.1 uwrhdxHtest_index 2 r STARTED 0 261b 127.0.0.1 9kTJ5Qetest_index 4 p STARTED 0 261b 127.0.0.1 uwrhdxHtest_index 4 r STARTED 0 261b 127.0.0.1 9kTJ5Qetest_index 0 p STARTED 0 261b 127.0.0.1 uwrhdxHtest_index 0 r STARTED 0 261b 127.0.0.1 9kTJ5Qe 可以发现 test_index 索引有 5 个主分片，每个主分片都有一个备份分片，并且主从分片不在一个节点上，5 个 primary shard 必须全部活动才能正常使用，否则集群 state = red 注：ES 索引一旦建立，不可改变，即 primary shard 不变 文档新增 Document 在索引中增加文档，如果增加的 document 对应的 index 不存在，自动创建，如果 index 存在， type 不存在也自动创建。 手动指定 id 的 Document 12345678910111213141516171819202122# Put /index/type/id &#123;field: value&#125;PUT /test_index/type1/1&#123; "name": "zjm", "remark": "IT boy", "no": 1&#125;# result:&#123; "_index": "test_index", # document 的索引 "_type": "type1", "_id": "1", "_version": 1, "result": "created", "_shards": &#123; "total": 2, # primary shard number "successful": 2, "failed": 0 &#125;, "_seq_no": 1, "_primary_term": 1&#125; 自动生成 id 1234567# POST /index/type&#123;field: value&#125;POST /test_index/my_type&#123; "name": "shaunjm", "remark": "my blog", "no": 2&#125; 注：每个 index 里的 document 结构差异不要太大！ 查询 Document GET 查询（单数据）：GET /index/type/id GET /_mget 批量查询（效率高，比单数据查询，推荐） 12345678910111213141516171819GET /_mget&#123; "docs": [ &#123; "_index": "...", "_type": "...", "_id": "..." &#125;, &#123;&#125;, &#123;&#125; ]&#125;# orGET /index/type/_mget&#123; "docs": [ &#123; "_id": "..." &#125;, &#123;&#125;, &#123;&#125; ]&#125; 替换 Document 替换 Document (全量替换) 语法同新增完全一样：PUT /index/type/id {field:value}，ES会先把原来 id 的文档标记为deleted，再新建，如果不存在 id 的数据则新增 PUT 的强制新增PUT /index/type/id/_create {} 或 PUT /index/type/id?op_type=create {}如果 id 已经存在则报错 更新 Document POST /index/type/id {&quot;doc&quot;:{field: value}} 只更新 id 文档的部分字段，先将原文档标记为 deleted，再将新字段和未更新的字段合并组成新的文档并创建。 删除 Document DELETE /index/type/id，标记文档为 deleted，不会直接物理删除，当 ES 存储空间不足时才会进行物理删除，状态标记为 deleted 的文档不会被查询搜索到 bulk 批处理增删改 Document12345678POST /_bulk&#123;"create": &#123;"_index": "index1", "_type": "type1", "_id": "1"&#125;&#125;&#123;"name": "zjm", "age": 10&#125;&#123;"index": &#123;"_index": "index1", "_type": "type1", "_id": "1"&#125;&#125;&#123;"name": "zjm22333", "age": 15&#125;&#123;"update": &#123;"_index": "index1", "_type": "type1", "_id": "1", "_retry_on_conflict": 3&#125;&#125;&#123;"doc": &#123;"age": 18&#125;&#125;&#123;"delete": &#123;"_index": "index1", "_type": "type1", "_id": "1"&#125;&#125; 2-3 行为强制新增，4-5 行为新增或全部替换，6-7 行为部分更新，8行为删除，一个文档的 json 中不能含有换行，不同的 json 串必须换行，这是为了字符串直接使用换行进行分隔，每一行为一个 json 对象，否则以 { 和 } 做分隔需要创建字符串数组，影响效率 Document Routing ES 将文档存放在 index 的哪个 primary shard 的路由机制： primary shard = hash(routing)%numbe_of_primary_shards 其中，routing 默认为 Document 的 id，也可以手动指定： PUT /index/type/id?routing=... 这样查询的时候也要带着 routing 值才能查询到，否则会按默认的 routing 值，即 id 进行计算 写操作：计算 routing 后决定写到哪个 primary shard 上， Primary shard 会自动同步对应的 replica shard；读操作：计算 routing 后决定读哪个 primary shard 或者对应的 replica shard，一个 primary shard 对应的 replica shard 越多，可选择的节点越多，并发性就越好 Document 读写流程 读：客户端发送的请求会随机的发送到一个节点上，称为协调节点（coordinate node），协调节点通过路由算法找到本次操作的 Document 所在的 shard，将请求转发 primary shard 或者对应的 replica shard（轮回策略或负载均衡），primary 或 replica shard 返回协调节点，协调节点再将相应返回给客户端 写：同样是随机发送请求到协调节点，协调节点计算出 Document 所在的 shard 后，转发到 shard 所在节点，primary shard 处理完请求后会同步对应的 replica shard，同步数据完成，返回结果到协调节点再到客户端]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>kibana</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[elasticSearch kibana install in linux]]></title>
    <url>%2F2018%2F08%2F01%2Felasticsearch-kibana-install%2F</url>
    <content type="text"><![CDATA[Linux 安装 ES ES 6.3.x 要求 Linux 内核必须是 3.5+版本以上，不能用 root 用户启动 uname -a 查看 linux 内核版本，低于3.5要升级内核，或者使用Centos7 升级内核 注册内核： rpm –import http://mirror.centos.org/centos/RPM-GPG-KEY-CentOS-7 下载内核安装包 rpm -Uvh http://www.elrepo.org/elrepo-release-6-8.el6.elrepo.noarch.rpm 安装内核新版本 yum --enablerepo=elrepo-kernel install kernel-lt -y 设置启动内核版本 vim /etc/grub.conf 修改为：default=0 重启系统让内核生效：reboot（还是直接用 Centos7 吧乖乖） 注意： 高版本的内核对线程的内存资源需要更高的要求，要给虚拟机分配 1.5G 以上的内存 配置虚拟机网关，DNS，保证能连接外网 ##为ES提供系统配置 ES 在 Linux 安装部署需要系统为其提供若干系统配置，如：应用可启动的线程数，可以划分到的内存，最多可以创建的文件… 修改限制信息 修改系统中允许应用创建最多文件个数的限制权限。Linux 默认限制应用最多创建 65535 个文件，但是 ES 至少需要65536 个文件的创建权限。 1234vi /etc/security/limits.conf# 增加* soft nofile 65536* hard nofile 65536 修改线程开启限制 修改允许用户启动的进程开启多少线程，Linux 限制 root 用户开启的进程可以启动任意数量的线程，其他用户开启的进程可以开启 1024 个线程。修改限制数为 4096+。ES 至少需要4096的线程池预备 123456vi /etc/security/limits.d/90-nproc.conf# 修改下述内容* soft nproc 4096root soft nproc unlimited# 检查可开启的最大线程ulimit -u 注：虚拟机内存是 1 G，最多能开启3000+个线程，不能满足ES的要求，所以要给虚拟机分配1.5G以上的内存 修改系统控制权限 系统控制文件是管理系统中资源控制的配置文件，ES需要开辟一个65536字节以上空间的虚拟内存。Linux默认不允许任何用户和应用直接开辟虚拟内存 12345vi /etc/sysctl.conf# 添加vm.max_map_count=655360# 让 sysctl 配置生效sysctl -p 安装JDK至少1.8.0_131+ 解压ES：tar -zxf elasticsearch-6.3.1.tar.gz 注：ES 不允许 root 用户启动，如果 ES 是通过 root 用户解压的，则所有者是 root 用户，需要将ES 应用所有者改为其他用户 修改所有者 123# 先移动到普通用户路径下： mv #path1 path2chown -R group.user elasticsearch... # 无组用户的组名和用户名一致 修改elasticsearch配置文件 设置可访问的客户端。0.0.0.0代表任意客户端访问。 123vi config/elasticsearch.yml# 修改下述内容network.host: 0.0.0.0 切换用户启动：su zjm，cd elasticsearch/bin，./elasticsearch 启动服务 测试连接：curl http://ip:9200 #Linux安装Kibana 是ES提供的一个Web的管理控制台，解压，启动即可，Kibana要求的环境配置是小于ES的 tar -zxf kibana.tar.gz 修改 config/kibana.yml，增加：server.host: “0.0.0.0” 运行：kibana_home/bin/kabana‘ 访问：http://ip:5601]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elasticSearch</tag>
        <tag>kibana</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-data-process]]></title>
    <url>%2F2018%2F02%2F26%2Fpython-data-process%2F</url>
    <content type="text"><![CDATA[前言 Python 科学计算中用到的数据处理，图像绘制的方法记录。好多不知道啥意思，先背住吧，用到的时候再找…Python 做科学计算东西挺多的，现在还不能自己掌握，得不断积累 随机生成正态分布的数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748__author__ = 'ZJM'__time__ = '2018/2/26 15:22'import numpy as npfrom numpy.linalg import choleskyimport matplotlib.pyplot as pltimport matplotlib.mlab as mlabfrom scipy.stats import multivariate_normalfrom sklearn.mixture import GaussianMixturefrom mpl_toolkits.mplot3d import Axes3DsampleNo = 1000# 一维正太分布mu = 3sigma = 15np.random.seed(0)s = np.random.normal(mu, sigma, sampleNo)plt.subplot(221)n, bins, patches = plt.hist(s, 50, normed=1)# add a best fit lineline = mlab.normpdf(bins, mu, sigma)plt.plot(bins, line, 'r--')plt.xlabel('x')plt.ylabel('y')plt.title(r'$\mu=' + str(mu) + '$, $\sigma=' + str(sigma) + '$')# 二维正态分布mu = np.array([1, 5])sigma = np.array([[1, 0], [0, 1.5]])R = cholesky(sigma)s = np.dot(np.random.randn(sampleNo, 2), R) + muplt.subplot(222)plt.plot(s[:, 0], s[:, 1], '+')# 三维正太分布mu = np.array([0] * 3)# sigma = np.array([[1, 1, 3], [1, 2, 1], [0, 0, 1]])sigma = np.diag((1, 1, 1))data = np.random.multivariate_normal(mu, sigma, 500)norm = multivariate_normal(mu, sigma)tau = norm.pdf(data)fig = plt.figure(figsize=(13, 7), facecolor='w')ax = fig.add_subplot(223, projection='3d')ax.scatter(data[:, 0], data[:, 1], data[:, 2], c='b', s=30, marker='o', depthshade=True)ax.set_xlabel('X')ax.set_ylabel('Y')plt.tight_layout()plt.show()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Scientific Computation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[math basic]]></title>
    <url>%2F2018%2F02%2F24%2Fmath-basic%2F</url>
    <content type="text"><![CDATA[前言 数学功底太差，概率论与数理统计、线性代数，大量概念理解不够，之前的强化记忆都为了应付考试，记题型、背步骤，现在用到数据处理和公式推导时发现都不会了。下面把一些用到的概念记录下，主要是看到的通俗的解释，直观形象的描述。尽量使概念活起来。^ - ^ 线代最小二乘法正交阵 n阶矩阵A，满足ATA=E，则A为正交阵 A=(a1,a2,…,an), A为正交阵，有： aiTai=1, aiTaj=0(i≠j) 即A的行(列)向量都是单位向量，且两两正交 单位向量保证ATA 对角线都是1，正交使得其他元素都是0 A, B 都是n阶正交阵，则A×B是正交阵 对称阵 协方差矩阵，二次型矩阵，无向图邻接矩阵都是对称阵 实对称阵不同特征值的特征向量正交 设A为n阶对称阵，则必有正交阵P，使得P-1AP = PTAP = Λ 其中P为A的特征向量组成的矩阵，Λ对角线上是A的特征值，即A为对称阵，做合同变换，特征值不变，A与Λ互为合同矩阵 正定阵 直观上：正定阵是一种实对称阵 对于n阶方阵A，若任意n阶非零向量x，都有xTAx&gt;0，则称A是正定阵。 给定任意m×n的矩阵A，ATA一定是半正定对称方阵 对称阵A是正定阵，A特征值都为正，A的顺序主子式都为正 向量的导数 问题：A为m×n的矩阵，x为n×1的列向量，则Ax为m×1的列向量，记y=Ax，y对x的偏导为AT 概率期望 平均数的扩展 小学的时候，考语数外，三科一样重要，期末成绩三科求和除以3即可得到平均分。大学了，每科都有学分，学分大的更重要，在所有科目中占的比重就大。求平均分时就要带着权重啦。xk 的概率pk 就相当于它的权重。期望反应数据的平均水平。 离散型： 连续型： 方差 衡量随机变量或一组数据时离散程度 在统计描述中： 在概率分布中： 离散型： ​ 展开后： 连续型： 协方差Cov 描述两个变量在变化过程中同向还是反向，及其程度。 你大我也大，同向，协方差为正 你大我小，反向，协方差为负 协方差数值绝对值越大则程度越强 相关系数ρ 也可以反映两个变量变化时是同向还是反向，如果同向变化就为正，反向变化就为负。 由于除以了两个变量的标准差，消除了变化幅度的影响，只考虑变化率的相似程度 似然函数 Likehood function 似然函数 是关于统计模型中的参数的函数 给定输出 x 时，关于参数θ的似然函数L(θ|x)=P(X=x|θ) 概率描述了已知参数时的随机变量的输出结果；似然描述已知随机变量输出结果时，未知参数的可能取值 离散型 L(θ|x) = P(X=x|θ) 或 P(X=x;θ) 连续型 L(θ|x) = f(x|θ) 求极大似然函数 写出似然函数 对似然函数取对数 求导数 解似然方程]]></content>
      <categories>
        <category>mechine learning</category>
      </categories>
      <tags>
        <tag>statistic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[backtracking questions]]></title>
    <url>%2F2018%2F02%2F23%2Fbacktracking-questions%2F</url>
    <content type="text"><![CDATA[回溯法求幂集、排列组合、回文区分幂集无重复元素发幂集 Given a set of distinct integers, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. For example,If nums = [1,2,3], a solution is:[[3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 1234567891011121314151617def subsets(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ ans = [] l = len(nums) def backtrack(tempList, start): ans.append(tempList) for i in range(start, l): tempList.append(nums[i]) backtrack(tempList[:], i+1) tempList.pop() backtrack([], 0) return ans 存在重复元素的幂集 Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. or example,If nums = [1,2,2], a solution is: [[2], [1], [1,2,2], [2,2], [1,2], []] 123456789101112131415161718192021def subsetWithDup(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ l = len(nums) ans = [] nums = sorted(nums) tempList = [] def backtrack(start): ans.append(tempList[:]) for i in range(start, l): if i &gt; start and nums[i] == nums[i-1]: # skip duplicates continue tempList.append(nums[i]) backtrack(i+1) tempList.pop() backtrack(0) return ans 全排列问题无重复元素的全排列 Given a collection of distinct numbers, return all possible permutations. For example,[1,2,3] have the following permutations: [[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 12345678910111213141516171819202122def permute(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ l = len(nums) ans = [] tempList = [] def backtrack(): if len(tempList) == l: ans.append(tempList[:]) else: for i in range(l): if nums[i] in tempList: continue tempList.append(nums[i]) backtrack() tempList.pop() backtrack() return ans 存在重复元素的全排列 Given a collection of numbers that might contain duplicates, return all possible unique permutations. For example,[1,1,2] have the following unique permutations: [[1,1,2], [1,2,1], [2,1,1]] 1234567891011121314151617181920212223242526def permuteWithUnique(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ nums = sorted(nums) l = len(nums) ans = [] tempList = [] used = [False] * l def backtrack(): if len(tempList) == l: ans.append(tempList[:]) else: for i in range(l): if used[i] or i &gt; 0 and nums[i] == nums[i-1] and not used[i-1]: continue used[i] = True tempList.append(nums[i]) backtrack() used[i] = False tempList.pop() backtrack() return ans Input: [3, 3, 0, 3] Output: [[0, 3, 3, 3], [3, 0, 3, 3], [3, 3, 0, 3], [3, 3, 3, 0]] 组合问题元素可以用多次 Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. For example, given candidate set [2, 3, 6, 7] and target 7,A solution set is: [ [7], [2, 2, 3] ] 123456789101112131415161718192021222324def combinationSum(self, candidates, target): """ :type candidates: List[int] :type target: int :rtype: List[List[int]] """ ans = [] l = len(candidates) tempList = [] candidates = sorted(candidates) def backtrack(remain, start): if remain &lt; 0: return if remain == 0: ans.append(tempList[:]) else: for i in range(start, l): tempList.append(candidates[i]) backtrack(remain-candidates[i], i) tempList.pop() backtrack(target, 0) return ans 元素只能用一次 Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. Each number in C may only be used once in the combination. For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,A solution set is: [[1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] 1234567891011121314151617181920212223242526def combinationSum2(self, candidates, target): """ :type candidates: List[int] :type target: int :rtype: List[List[int]] """ l = len(candidates) ans = [] templist = [] candidates = sorted(candidates) def backtrack(remain, start): if remain &lt; 0: return if remain == 0: ans.append(templist[:]) else: for i in range(start, l): if i &gt; start and candidates[i] == candidates[i-1]: continue templist.append(candidates[i]) backtrack(remain - candidates[i], i+1) templist.pop() backtrack(target, 0) return ans 找回文子集 Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s. For example, given s = &quot;aab&quot;,Return [[&quot;aa&quot;,&quot;b&quot;], [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]] 1234567891011121314151617181920212223242526272829def partition(self, s): """ :type s: str :rtype: List[List[str]] """ l = len(s) ans = [] tempList = [] def isPalindrome(low, high): while low &lt; high: if s[low] != s[high]: return False low += 1 high -= 1 return True def backtrack(start): if start == l: ans.append(tempList[:]) else: for i in range(start, l): if isPalindrome(start, i): tempList.append(s[start: i+1]) backtrack(i+1) tempList.pop() backtrack(0) return ans summary: 我还没看懂… 以后再更新 -_-||| Copy from：https://leetcode.com/problems/subsets/discuss/27281/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java map-reduce]]></title>
    <url>%2F2018%2F02%2F11%2Fjava-map-reduce%2F</url>
    <content type="text"><![CDATA[Java开发Map/Reduce程序MR程序执行方式： 在本地运行，输入输出都在本地，用于调试程序 把远程数据拉到本地运行，输出传回远程，只适合数据量小 在远程运行，输入输出都在远程 ##Java程序在服务器上运行 配置系统环境变量HADOOP_HOME，指向hadoop安装目录（如果你不想招惹不必要的麻烦，不要在目录中包含空格或者中文字符） 把HADOOP_HOME/bin加到PATH环境变量（非必要，只是为了方便） 如果是在windows下开发，需要添加windows的库文件 把盘中共享的bin目录覆盖HADOOP_HOME/bin 如果还是不行，把其中的hadoop.dll复制到c:\windows\system32目录下，可能需要重启机器 maven引入依赖 新建项目，引入hadoop 所需要的jar文件 1234567891011121314151617181920212223242526&lt;properties&gt; &lt;project.build.sourceencoding&gt;UTF-8&lt;/project.build.sourceencoding&gt; &lt;hadoop.version&gt;2.7.3&lt;/hadoop.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-client&lt;/artifactId&gt; &lt;version&gt;$&#123;hadoop.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-common&lt;/artifactId&gt; &lt;version&gt;$&#123;hadoop.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-hdfs&lt;/artifactId&gt; &lt;version&gt;$&#123;hadoop.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 代码WordMapper.java1234567891011121314151617181920212223package com.zjm;import java.io.IOException;import org.apache.hadoop.io.IntWritable;import org.apache.hadoop.io.LongWritable;import org.apache.hadoop.io.Text;import org.apache.hadoop.mapreduce.Mapper;public class WordMapper extends Mapper&lt;LongWritable, Text, Text, IntWritable&gt;&#123; @Override protected void map(LongWritable key, Text value, Mapper&lt;LongWritable, Text, Text, IntWritable&gt;.Context context) throws IOException, InterruptedException &#123; final IntWritable ONE = new IntWritable(1); String s = value.toString(); String[] words = s.split(" "); for(String word: words) &#123; context.write(new Text(word), ONE); &#125; &#125; &#125; WordReduce.java12345678910111213141516171819202122package com.zjm;import java.io.IOException;import org.apache.hadoop.io.IntWritable;import org.apache.hadoop.io.LongWritable;import org.apache.hadoop.io.Text;import org.apache.hadoop.mapreduce.Reducer;public class WordReducer extends Reducer&lt;Text, IntWritable, Text, LongWritable&gt;&#123; @Override protected void reduce(Text key, Iterable&lt;IntWritable&gt; values, Reducer&lt;Text, IntWritable, Text, LongWritable&gt;.Context context) throws IOException, InterruptedException &#123; long count = 0; for(IntWritable v: values) &#123; count += v.get(); &#125; context.write(key, new LongWritable(count)); &#125;&#125; main函数1234567891011121314151617181920212223242526272829303132333435363738package com.zjm;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.fs.Path;import org.apache.hadoop.io.IntWritable;import org.apache.hadoop.io.LongWritable;import org.apache.hadoop.io.Text;import org.apache.hadoop.mapreduce.Job;import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;public class Test &#123; public static void main(String[] args) throws Exception&#123; Configuration conf = new Configuration(); conf.set("fs.defaultFS", "hdfs://master:9000/"); // 将项目打包到项目跟目录下 conf.set("mapreduce.job.jar", "wc.jar"); conf.set("mapreduce.framework.name", "yarn"); conf.set("yarn.resourcemanager.hostname", "master"); conf.set("mapreduce.app-submission.cross-platform","true"); Job job = Job.getInstance(conf); job.setMapperClass(WordMapper.class); job.setReducerClass(WordReducer.class); job.setMapOutputKeyClass(Text.class); job.setMapOutputValueClass(IntWritable.class); // Reduce 的输出类型 job.setOutputKeyClass(Text.class); job.setOutputValueClass(LongWritable.class); FileInputFormat.setInputPaths(job, "/input/"); FileOutputFormat.setOutputPath(job, new Path("/output")); job.waitForCompletion(true); &#125;&#125; 注： win系统的hosts文件添加虚拟机的IP和主机名 配置hadoop在win系统的环境变量 Run as —— Run Configurations —— Arguments —— VM arguments: -DHADOOP_USER_NAME=root]]></content>
      <categories>
        <category>Big Data</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yarn&Map/Reduce]]></title>
    <url>%2F2018%2F02%2F09%2FYarn-Map-Reduce%2F</url>
    <content type="text"><![CDATA[分布式计算 设计原则：移动计算，不移动数据 Yarn Yarn: 资源调度 主从结构：ResourceManager 和 NodeManager ResourceManager 将任务分配给空闲的机器(slave)工作，NodeManager在slave中做具体的资源利用，RM管理NM yarn-site.xml的配置 修改ResourceManager和NodeManager的vim hadoop/etc/hadoop/yarn-site.xml 1234567891011121314&lt;property&gt; &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt; &lt;value&gt;master&lt;/value&gt;&lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.auxservices.mapreduce.shuffle.class&lt;/name&gt; &lt;value&gt;org.apache.hadoop.mapred.ShuffleHandler&lt;/value&gt;&lt;/property&gt; ###启动yarn集群 start-yarn.sh 访问8088端口 Map/Reduce 在 ResourceManager上配置mapred-site.xml 1234&lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt;&lt;/property&gt; 执行示例程序 1hadoop jar /usr/local/hadoop/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.3.jar wordcount /input/input.txt /output 查看运行结果 hadoop fs -text /output/part-r-00000 Map/Reduce 流程 input split 拆分（一行一行） map 映射（键值对） shuffle 派发（键值对派发到一个nodeManager） reduce 缩减（按键统计值的和） output]]></content>
      <categories>
        <category>Big Data</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java hdfs]]></title>
    <url>%2F2018%2F02%2F08%2Fjava-hdfs%2F</url>
    <content type="text"><![CDATA[Java程序访问HDFS导入所需的jar文件 12345678910111213&lt;!-- https://mvnrepository.com/artifact/org.apache.hadoop/hadoop-common --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-common&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.apache.hadoop/hadoop-hdfs --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-hdfs&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt;&lt;/dependency&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package dbfs;import java.io.FileInputStream;import java.math.BigDecimal;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.fs.FSDataOutputStream;import org.apache.hadoop.fs.FileStatus;import org.apache.hadoop.fs.FileSystem;import org.apache.hadoop.fs.Path;import org.apache.hadoop.io.IOUtils;public class HelloHDFS &#123; public static void main(String args[]) throws Exception &#123;// URL.setURLStreamHandlerFactory(new FsUrlStreamHandlerFactory());// URL url = new URL("hdfs://192.168.137.100:9000/hello.txt");// InputStream in = url.openStream();// IOUtils.copyBytes(in, System.out, 4096, true); Configuration conf = new Configuration(); conf.set("fs.defaultFS", "hdfs://192.168.137.100:9000"); // 修改hdfs配置参数值 conf.set("dfs.replication", "5"); FileSystem fileSystem = FileSystem.get(conf); // 判断路径是否存在 boolean success = fileSystem.exists(new Path("/zjm")); System.out.println(success); // 新建路径，注意如果已经存在同名目录会覆盖原目录x_x success = fileSystem.mkdirs(new Path("/zjm")); System.out.println(success); // 删除 success = fileSystem.delete(new Path("/zjm"), true); System.out.println(success); // 上传文件 FSDataOutputStream out = fileSystem.create(new Path("/test.data")); FileInputStream fis = new FileInputStream("F:learn/mashibing/hadoop/马士兵hadoop2.7入门_03.mp4"); IOUtils.copyBytes(fis, out, 4096, true); fileSystem.delete(new Path("/video"), true); // 上传文件：IO流可计算上传进度 FSDataOutputStream out = fileSystem.create(new Path("/video")); FileInputStream in = new FileInputStream("F:learn/mashibing/hadoop/马士兵hadoop2.7入门_03.mp4"); int total = in.available(); byte[] buf = new byte[4096]; int len = in.read(buf); int now = len; while(len != -1) &#123; // 上传百分比，保留小数点后两位 System.out.println(new BigDecimal((float)now/total*100).setScale(2, BigDecimal.ROUND_HALF_UP).doubleValue()); out.write(buf, 0, len); len = in.read(buf); now += len; &#125; in.close(); out.close(); // 查看文件结构 FileStatus[] statuses = fileSystem.listStatus(new Path("/")); for(FileStatus status: statuses) &#123; System.out.println(status.getPath()); System.out.println(status.getPermission()); System.out.println(status.getReplication()); &#125; &#125;&#125; 注：需要关闭权限检查，向hdfs-site.xml中添加并重启hdfs 1234&lt;property&gt; &lt;name&gt;dfs.permissions.enabled&lt;/name&gt; &lt;value&gt;false&lt;/value&gt;&lt;/property&gt; description: If “true”, enable permission checking in HDFS. If “false”, permission checking is turned off, but all other behavior is unchanged. Switching from one parameter value to the other does not change the mode, owner or group of files or directories.]]></content>
      <categories>
        <category>Big Data</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hadoop hdfs]]></title>
    <url>%2F2018%2F02%2F06%2Fhadoop-hdfs%2F</url>
    <content type="text"><![CDATA[在多台服务器上配置Hadoop 启动namenode和datanode hadoop-daemon.sh start namenode(datanode) 在master上检测datanode hdfs dfsadmin -report | more 在web页面观察hadoop集群情况 192.168.137.100:50070 集中管理Slaves 在/usr/local/hadoop/etc/hadoop下的slaves文件中添加slaves的主机名，在master中就可以管理其中的所有slaves，如： 123slave1slave2slave3 执行：start-dfs.sh，输入master, slave, secondaryNameNode的密码 为了避免输入多次的密码，在 /.ssh 下执行 ssh-keygen -t rsa 回车三次，发现.ssh下生成两个文件：id_ras （私钥）和 id_ras.pub（公钥） 从master发送公钥到master, slave1, slave2, slave3：ssh-copy-id master, ssh-copy-id slave1, ssh-copy-id slave2, ssh-copy-id slave3 以后ssh IP 就不用再输入密码了，再执行start-dfs.sh时就不用再次输入密码了 hdfs文件系统指令 hadoop fs -ls或hdfs dfs -ls 放置一个文件到hdfs中：hadoop fs -put file / 通过网页观察现象：http://192.168.137.100:50070/explorer.html#/ 指令： hadoop fs -mkdir /dirname hadoop fs -text /filename 查看文本文件内容 hadoop fs -rm /filename 配置参数 编写/hadoop/etc/hadoop/hdfs-site.xml eg: 修改复制的个数为2份（默认为3份）： 1234&lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;2&lt;/value&gt;&lt;/property&gt;]]></content>
      <categories>
        <category>Big Data</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hadoop配置环境及启动]]></title>
    <url>%2F2018%2F02%2F05%2Fhadoop-day1%2F</url>
    <content type="text"><![CDATA[VirtualBox启动虚拟机 host-only方式连接虚拟机 安装Hadoop 连接虚拟机 查看虚拟网卡的IP地址(assume:192.168.137.1)，VM设置网卡类型为host-only 设置ipv4地址 vim /etc/sysconfig/network-scripts/ifcfg-enp03 IPADDR=192.168.137.100 NETMASK=255.255.255.0 设置网关地址 vim /etc/sysconfig/network NETWORKING=yes GATEWAY=192.168.137.1 修改主机名 hostnamectl set-hostname master 重启network服务 service network restart 互相ping 虚拟机：ping 192.168.137.1 电脑：ping 192.168.137.100 安装Hadoop 打开Xftp上传jdk，hadoop安装文件至/usr/local目录下 安装jdk rpm -ivh jdk-8u91-linux-x64.rpm 解压hadoop cd local tar -xvf hadoop-2.7.3.tar.gz 发现local目录下多了hadoop-2.7.3的目录(改名为了方便：mv hadoop-2.7.3 haddop) 配置Hadoop JDK路径 cd hadoop/etc/hadoop vim hadoop-env.sh export JAVA_HOME=/usr/java/default 将hadoop执行命令添加到path环境变量里 vim /etc/profile 添加：export PATH=$PATH:/usr/local/hadoop/bin:/usr/local/hadoop/sbin 执行： source /etc/profile 以这台虚拟机做master，复制出三台虚拟机做slaver，配置IP和网关，改主机名分别为slave1, slave2, slave3 启动Hadoop配置所有虚拟机1234567cd /usr/local/hadoop/etc/hadoopvim core-site.xml # master管理结点，slave知道master&lt;!-- 在&lt;configuration&gt;内添加：--&gt;&lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://master:9000&lt;/value&gt;&lt;/property&gt; 修改所有虚拟机的host文件 vim /etc/hosts eg 1234192.168.137.100 master192.168.137.101 slave1192.168.137.102 slave2192.168.137.103 slave3 格式化namenode(仅master) hdfs namenode -format 启动namenode(仅master) hadoop-daeman.sh start namenode 输入jps，出现NameNode则namenode启动 启动datanode(slaver) hadoop-daemon.sh start datanode]]></content>
      <categories>
        <category>Big Data</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[laravel基础]]></title>
    <url>%2F2017%2F09%2F13%2Flaravel%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[安装错误 solution: 打开运行环境中的php.ini，用快速查找找到 extension=php_openssl.dll 此项，然后把该代码前面的分号去掉，最后重启运行环境，刷新页面 路由 作用: 将请求映射到程序（处理函数） laravel/app/Http/routes.php: 基础路由 123Route::get('basic1',function () &#123; return 'Hello World';&#125;); 多请求路由 123Route::match(['get','post'], 'multy', function () &#123; return 'multy';&#125;); 所有请求种类路由 123Route::any('allRequest',function() &#123; return 'all request';&#125;); 路由参数 123Route::get('user/&#123;id&#125;/&#123;name?&#125;',function ($id,$name=null) &#123; return 'User-id'.$id.'User-name:'.$name;&#125;)-&gt;where(['id'=&gt;'[0-9]+','name'=&gt;'[A-Za-z]+']); 路由别名 123Route::get('user/center',['as'=&gt;'center', function() &#123; return route('center');&#125;]); 路由群组 12345678Route::group(['prefix'=&gt;'member'], function ()&#123; Route::get('basic2',function() &#123; return 'Basic2'; &#125;); Route::get('user/center',['as'=&gt;'center', function() &#123; return route('center'); &#125;]);&#125;); 路由输出视图 123Route::get('view', function ()&#123; return view('welcome');&#125;); 控制器 laravel/app/Http/Controllers: 路由将请求发送给控制器，控制器处理请求并返回相应 路由和控制器中的方法关联： 1234567891011Route::get('member/info','MemberController@info');Route::get('member/info',['uses'=&gt;'MemberController@info']);Route::get('member/info',[ 'uses' =&gt; 'MemberController@info', 'as' =&gt; 'member_info']);Route::get('member/find/&#123;id&#125;','MemberController@find')-&gt;where('id','[0-9]+'); 控制器中有对应路由请求的函数： 12345678910111213141516171819namespace App\Http\Controllers;class MemberController extends Controller &#123; public function info() &#123; //return 'member-info'; return route('member_info'); &#125; // 接收请求参数 public function find($id) &#123; return 'member'.$id; &#125; // 返回一个视图，向视图中传递数据 public function toInfo() &#123; return view('member/info',[ 'name' =&gt; 'shaun', 'age' =&gt; 18 ]); &#125;&#125; 视图 laravel/resources/views: 控制器的方法返回一个视图，并传递参数给视图，视图使用模板解析展示数据 laravel 默认模板文件名为：xxx.blade.php 用 的形式获取变量值 模型 laravel/app: 123456789namespace App;use Illuminate\Database\Eloquent\Model;class Member extends Model &#123; public static function getMember() &#123; return 'member name is shaun'; &#125;&#125; 数据库操作DB facade 配置：laravel/config/database.php laravel/.env 使用 DB facade 实现 CURD 1234567891011121314151617181920212223namespace App\Http\Controllers;use Illuminate\Support\Facades\DB;class UserController extends Controller &#123; public function curd() &#123; // 返回是否插入成功 $bool = DB::insert('insert into user(name,sex,phone,email) VALUES(?,?,?,?) ', ['zcl','1','1365656556','zcl@163.com']); var_dump($bool); // 返回查询结果的数组 $users = DB::select('select* from user'); dd($users); // json格式 // 返回变动的数量 $num = DB::update('update user set age=? where name = ?', [18,'zjm']); var_dump($num); // 返回删除的条数 $num = DB::delete('delete from user where id=?', [3]); var_dump($num); &#125;&#125; 查询构造器 Laravel 查询构造器 (query builder) 提供接口，用来建立及执行数据库查找语法 使用 PDO 参数绑定，以保护应用程序免于 SQL 注入，传入的参数不需要额外转义特殊字符 基本可以满足所有的数据库操作 使用查询构造器新增数据 123456789101112131415161718// 返回bool插入是否成功DB::table('user')-&gt;insert([ 'name' =&gt; 'ms', 'sex' =&gt; '0', 'age' =&gt; '18', 'phone' =&gt; '13666666666', 'email' =&gt; 'maoshuo@gmail.com']);// 返回插入的 id$id = DB::table('user')-&gt;insertGetId([ 'name' =&gt; 'shaun', 'age' =&gt; 19]);// 插入多条记录，二维数组存放信息，返回boolDB::table('user')-&gt;insert([ ['name' =&gt; '张三', 'age' =&gt; 21], ['name' =&gt; '李四', 'age' =&gt; 22],]); 使用查询构造器更新数据 更新数据 自增自减 123456789101112// 返回受影响的行数$num = DB::table('user') -&gt;where('id',7) -&gt;update([ 'name' =&gt; 'zjm' ]);var_dump($num);// 自减同时更新子段值$num = DB::table('user') -&gt;where(['id'=&gt;7]) // -&gt;where('id',7) -&gt;decrement('age',3, ['name' =&gt; 'zjmhaha']); //increment 自增 decrement 自减var_dump($num); 使用查询构造器删除数据 delete trancate——清空表… 12345678$num = DB::table('user') -&gt;where('id',7) -&gt;delete();var_dump($num);$num = DB::table('user') -&gt;where('id', '&gt;=', 13) -&gt;delete();var_dump($num); 使用查询构造器查询数据 get()——获取结果集所有数据 first()——获取结果集中第一条 where()——查询条件，whereRaw()——多条件查询 pluck()——返回结果集中指定的字段 lists()——类似pluck select()——查询指定的字段 chunk() ——分页返回所有结果集 1234567891011121314151617181920212223242526272829public function search() &#123; // get() 获取表中所有数据 $users = DB::table('user')-&gt;get(); // first 获取结果集第一条 $users = DB::table('user') -&gt;orderBy('id','desc') // 倒序 -&gt;first(); $users = DB::table('user') -&gt;where('age','&gt;=',20) -&gt;get(); // 多条件查询 $users = DB::table('user') -&gt;whereRaw('id &gt;= ? and age &gt; ?', [2, 20]) -&gt;get(); // pluck 返回结果集中指定的字段 $name = DB::table('user')-&gt;pluck('name'); //$name = DB::table('user')-&gt;lists('name', 'id'); //dd($name); //select 查询指定的字段 $users = DB::table('user') -&gt;select('id','name','age') -&gt;get(); // chunk echo '&lt;pre&gt;'; $num = DB::table('user')-&gt;chunk(2, function($users) &#123; var_dump($users); &#125;); var_dump($num); &#125; 查询构造器中的聚合函数 count() max() min() avg() sum() 12345678// 聚合函数public function aggregate() &#123; $num = DB::table('user')-&gt;count(); $num = DB::table('user')-&gt;max('age'); $num = DB::table('user')-&gt;min('age'); $num = DB::table('user')-&gt;avg('age'); $num = DB::table('user')-&gt;sum('age');&#125; 数据库操作-Eloquent ORM 数据表和一个相对应的模型 (Model) 用于和数据表交互 查询构造器在ORM中依旧有应用 模型建立 laravel/app: 12345678910namespace App;use Illuminate\Database\Eloquent\Model;class Student extends Model &#123; // 指定表名，默认为 students protected $table = 'student'; // 指定id,默认为id protected $id = 'id';&#125; ORM 查询123456789101112131415161718192021public function orm() &#123; // 查询所有 $students = Student::all(); // 按主键查询 $student = Student::find(1); // 找不到id报错 $student = Student::findOrFail(2); // 查询构造器在ORM中使用 $students = Student::get(); $student = Student::where('age','&gt;',18) -&gt;orderBy('age','desc') -&gt;first(); dd($student); echo '&lt;pre&gt;'; Student::chunk(2, function ($students) &#123; var_dump($students); &#125;); $num = Student::count(); $max = Student::where('age','&gt;',18)-&gt;max('age'); var_dump($max); &#125; ORM中新增，自定义时间戳及批量赋值 通过模型新增数据（自定义时间戳） 使用模型的Create方法新增数据（批量赋值） 模型属性的定义，方法重写123456789101112131415161718192021222324252627namespace App;use Illuminate\Database\Eloquent\Model;class Student extends Model &#123; // 指定表名，默认为 students protected $table = 'student'; // 指定id,默认为id protected $id = 'id'; // 指定允许批量赋值的字段 protected $fillable = ['name', 'age']; // 指定不允许批量赋值的字段// protected $guarded = []; // 关闭created_at 和 updated_at public $timestamps = true; // 自意义返回时间戳 /*protected function getDateFormat() &#123; return time(); &#125;*/ // /*protected function asDateTime( $value ) &#123; return $value; &#125;*/&#125; 注：由于laravel自定义添加的created_at时间不是北京时间，可以将数据库 created_at字段类型改为 int，重写模型的 getDateFormat()方法，如果希望返回时间戳(数字形式)，再重写asDateTime()函数 四种常用的ORM新增1234567891011121314151617181920212223242526272829public function orm2() &#123; // 使用模型新增数据 /*$student = new Student(); $student-&gt;name = 'ms'; $student-&gt;age = 18; $bool = $student-&gt;save(); dd($bool);*/ /*$Student = Student::find(3); echo $Student-&gt;created_at.'&lt;br&gt;'; echo date('Y-m-d H:i:s', 1464509164);// 只对于数字时间戳*/ // 使用模型的Create方法新增数据，这里的属性必须为模型中指定允许批量赋值的字段 /*$student = Student::create([ 'name' =&gt; 'zjm', 'age' =&gt; 18 ]); dd($student);*/ //firstOrCreate() 按属性查找，没有找到则新加 /*$student = Student::firstOrCreate([ 'name' =&gt; 'zjm22333' ]); dd($student);*/ //firstOrNew() 按属性查找，没有则建立新的实例，自己调用save()保存 $student = Student::firstOrNew([ 'name' =&gt; 'zjm123123' ]); $student-&gt;save(); dd($student); &#125; 注： 使用模型的Create方法新增数据，这里的属性必须为模型中指定允许批量赋值的 使用Eloquent ORM修改数据 通过模型更新 结合查询语句 批量更新 1234567$student = Student::find(8);$student-&gt;name = 'shaun';$bool = $student-&gt;save();var_dump($bool);Student::where('id','&gt;',7)-&gt;update([ 'age' =&gt; 23]); 注： 使用ORM的save()方法更新子段必须使模型的主键和数据库表主键相同，包括大小写 模型中默认主键名：id 重写模型中主键名：protected $primaryKey = &#39;Id&#39;; 使用Eloquent ORM删除数据 通过模型删除 通过主键值删除 根据指定条件删除 123456789// 通过模型删除（没有会报错）$student = Student::find(9);$bool = $student-&gt;delete();// 通过主键删除,返回删除个数$num = Student::destroy(7);$num = Student::destroy(7,8,9);$num = Student::destroy([7,8,9]);// 条件删除$num = Student::where('id', '&gt;', 6)-&gt;delete(); Blade模板引擎Blade模板引擎简介及模板继承的使用 页面公共的部分提取出来形成一个父类，方便开发和维护 @section…@show @yield 12345@extends(&apos;layouts&apos;)&lt;!-- 继承 views下的基类视图 --&gt;@section(&apos;header&apos;) @parent &lt;!-- 父模板内容 --&gt; self_content@stop 基础语法及include的使用 在控制器中返回视图并传入参数 123return view('student.section1', [ 'name' =&gt; $name]); 在模板中输出参数值 1234567891011121314151617&gt; &#123;&#123; $name &#125;&#125;&gt; &lt;!-- 调用php函数，执行php代码 --&gt;&gt; &#123;&#123; time() &#125;&#125;&gt; &#123;&#123; date(&apos;Y-m-d H:i:s&apos;, time()) &#125;&#125;&gt; &#123;&#123; in_array($name, $arr) ? &apos;true&apos; : &apos;false&apos;&#125;&#125;&gt; &#123;&#123; var_dump($arr) &#125;&#125;&gt; &lt;!-- 存在输出，不存在输出默认 --&gt;&gt; &#123;&#123; isset($name) ? $name:&apos;default&apos; &#125;&#125;&gt; &lt;!-- 可简化为： --&gt;&gt; &#123;&#123; $name or &apos;default&apos; &#125;&#125;&gt; &lt;!-- 原样输出 --&gt;&gt; @&#123;&#123; $name &#125;&#125;&gt; &lt;!-- 模板中的注释：不在页面源码中显示 --&gt;&gt; &#123;&#123; -- 你的注释 -- &#125;&#125;&gt; &lt;!-- 引入子视图 --&gt;&gt; @include(&apos;student.common1&apos;)&gt; 流程控制123456789101112131415161718192021222324252627282930@if ($name == &apos;zzz&apos;) I&apos;m zzz@elseif($name == &apos;aaa&apos;) I&apos;m aaa@else ...@endif@if(in_array($name, $arr)) true@else false@endif@unless($name == &apos;zjm&apos;) &lt;!--if的取反--&gt; I&apos;m zjm@endunless@for($i=0; $i &lt; 10; $i++) &#123;&#123; $i &#125;&#125;@endfor @foreach($students as $student) &lt;p&gt;&#123;&#123; $student-&gt;name &#125;&#125;&lt;/p&gt; @endforeach@forelse($students as $student) &lt;p&gt;&#123;&#123; $student-&gt;name &#125;&#125;&lt;/p&gt; @empty &lt;p&gt;无数据&lt;/p&gt; @endforelse 模板中的URL url()——通过路由名字 action()——通过制定控制器的方法名 route()——通过路由别名 123&lt;a href="&#123;&#123; url('url) &#125;&#125;"&gt;&lt;/a&gt; &lt;a href="&#123;&#123; action('StudentController.urlTest') &#125;&#125;"&gt;&lt;/a&gt; &lt;a href="&#123;&#123; route('url') &#125;&#125;"&gt;&lt;/a&gt; `]]></content>
      <categories>
        <category>web服务</category>
      </categories>
      <tags>
        <tag>php框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求所有LCS的简单算法及矩阵搜索算法]]></title>
    <url>%2F2017%2F08%2F21%2FLCS%2F</url>
    <content type="text"><![CDATA[动态规划——最长公共子序列（LCS）背景知识 子序列： 原序列 X，将 X 中的元素组成新序列 Z，这些元素的先后位置与原序列相对一致，Z 是 X 的一个子序列 最长公共子序列： 若 Z 是 X 的子序列 , Z 也是 Y 的子序列，且不存在比 Z 更长的 X 和 Y 的公共子序列，则称 Z 是 X 和 Y 的最长公共子序列 ，记为 Z ∈LCS( X , Y) 。最长公共子序列往往不止一个 eg: X = { A，B，C，B，D，A，B }，Y = { B，D，C，A，B，A }，则 { B，C，B，A } 是 X 和 Y 的一条公共子序列，由于没有更长的公共子序列，故也是一条最长公共子序列 最长公共子序列的结构 在穷举法中，将 X 中所有子序列，检查它是否也是 Y 的子序列，确定是公共子序列后记录最长的公共子序列。设 X 有 m 个元素，则它的子序列有 2m个，穷举法需要指数时间 最长公共子序列具有最优子结构 设序列 X = { x1，x2，···，xm } 和 Y = { y1，y2，···，yn } 的最长公共子序列为 Z = { z1，z2，···，zk }，则 若 xm = yn，则 zk = xm = yn，且Zk-1 是 Xm-1 和 Yn-1 的最长公共子序列 若 xm ≠ yn，且 zk ≠ xm，则 Z 是 Xm-1 和 Y 的最长公共子序列 若 xm ≠ yn，且 zk ≠ yn，则 Z 是 X 和 Yn-1 的最长公共子序列 子问题的递归结构 如果从顶向下计算，将出现大量的子问题重叠…动态规划的基本思想是从低向上计算不同子问题，通过底部子问题的解，得出顶部问题的解。最终目的是得到最顶上问题的解。 建立两个矩阵 c 和 b，矩阵 c 用来存放 i, j 位置的最长公共子序列长度(简记为LCS长度)，矩阵 b 存放i, j 位置是由哪个方向来的，方便回溯 建立递归关系如下： c[i,j]={0,i=0 or j=0c[i−1,j−1]+1,i,j&gt;0 and xi=yjmax(c[i−1,j],c[i,j−1]),i,j&gt;0 and xi≠yjc[i,j]=\begin{cases} 0, &amp; i=0\ or\ j=0\\ c[i-1,j-1]+1,&amp;i,j&gt;0\ and\ x_i=y_j\\ max(c[i-1,j],c[i,j-1]), &amp;i,j&gt;0\ and\ x_i\ne y_j \end{cases} c[i,j]=​⎩​⎪​⎨​⎪​⎧​​​0,​c[i−1,j−1]+1,​max(c[i−1,j],c[i,j−1]),​​​i=0 or j=0​i,j&gt;0 and x​i​​=y​j​​​i,j&gt;0 and x​i​​≠y​j​​​​ b[i,j]={1,i,j&gt;0 and xi=yj2,i,j&gt;0 and xi≠yj and c[i−1,j]&gt;c[i,j−1]3,i,j&gt;0 and xi≠yj and c[i−1,j]≤c[i,j−1] b[i,j]=\begin{cases} 1,&amp;i,j&gt;0\ and\ x_i=y_j\\ 2, &amp;i,j&gt;0\ and\ x_i\ne y_j\ and\ c[i-1,j]&gt;c[i,j-1]\\ 3, &amp;i,j&gt;0\ and\ x_i\ne y_j\ and\ c[i-1,j]\leq c[i,j-1] \end{cases} b[i,j]=​⎩​⎪​⎨​⎪​⎧​​​1,​2,​3,​​​i,j&gt;0 and x​i​​=y​j​​​i,j&gt;0 and x​i​​≠y​j​​ and c[i−1,j]&gt;c[i,j−1]​i,j&gt;0 and x​i​​≠y​j​​ and c[i−1,j]≤c[i,j−1]​​ 图中右下角 5(2) 表示 (8, 8) 位置的LCS长度为5，由上面的位置 (7, 8) 得到 右下角的值就是LCS长度，从该点通过矩阵 b 回溯，遇到 2 向上走，遇到 3 向左走，遇到 1 斜上走，当遇到边缘时(i=0 或 j=0)停止，既可以得到一条最长公共子序列 这样做只能得到两串的一条最长公共子序列，因为当 c[i−1,j]=c[i,j−1] 时可以向上也可以向左，但是我们指定它向左了，这样就不会出现不同的情况。于是，可以添加一种 b 的值： b[i,j]=4, i,j&gt;0 and xi≠yj and c[i−1,j]=c[i,j−1]b[i,j]=4,\ \ \ \ i,j&gt;0\ and\ x_i\ne y_j\ and\ c[i-1,j]=c[i,j-1]b[i,j]=4, i,j&gt;0 and x​i​​≠y​j​​ and c[i−1,j]=c[i,j−1] 当 b[i][j] = 4 时(下文称为分叉点)，向上走也向左走，这样可以遍历到所有的路径 如图，当遇到分叉点的时候将分出两个路径，将所有分叉点作为非叶子结点组成一棵二叉树： 最下面的叶子结点个数就是所有路径个数 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;set&gt;using namespace std;int num = 0; // 记录遍历路径数int** getArr(int,int); // 动态创建二维数组void LCS(int**,int**,string,string,int,int); // 给 c,b 数组赋值void TraceBack(string,string,int**,int,int); // 回溯路径set&lt;string&gt; setOfLCS; // set保存所有的LCS，set集合中元素不重复int main() &#123; string s1,s2; cin&gt;&gt;s1&gt;&gt;s2; int len1 = s1.size() + 1; int len2 = s2.size() + 1; int** c = getArr(len1,len2); int** b = getArr(len1,len2); // 使 s1,s2 与 c,b 坐标一致 s1 = " " + s1; s2 = " " + s2; // 自底向上给 c,b 数组赋值 LCS(c,b,s1,s2,len1,len2); // 显示 c,b 数组 for(int i=0;i&lt;len1;i++) &#123; for(int j=0;j&lt;len2;j++) &#123; cout&lt;&lt;c[i][j]&lt;&lt;" "; if(j == len2-1) cout&lt;&lt;endl; &#125; &#125; cout&lt;&lt;"===============================\n"; for(int i=0;i&lt;len1;i++) &#123; for(int j=0;j&lt;len2;j++) &#123; cout&lt;&lt;b[i][j]&lt;&lt;" "; if(j == len2-1) cout&lt;&lt;endl; &#125; &#125; // 从右下角根据 b 数组指向回溯到边界 TraceBack(s1,"",b,len1-1,len2-1); cout&lt;&lt;"All route number: "&lt;&lt;num&lt;&lt;endl; cout&lt;&lt;"Remove duplicate elements: "&lt;&lt;endl; // 遍历set，输出所有LCS set&lt;string&gt;::iterator iter=setOfLCS.begin(); while(iter != setOfLCS.end()) &#123; cout&lt;&lt;*iter&lt;&lt;endl; iter++; &#125; cout&lt;&lt;"LCS length: "&lt;&lt;c[len1-1][len2-1]&lt;&lt;endl; cout&lt;&lt;"LCS number: "&lt;&lt;setOfLCS.size()&lt;&lt;endl; return 0;&#125;void LCS(int** c,int** b,string s1,string s2,int m,int n) &#123; for(int i=1;i&lt;m;i++) &#123; for(int j=1;j&lt;n;j++) &#123; if(s1[i] == s2[j]) &#123; c[i][j] = c[i-1][j-1] + 1; b[i][j] = 1; // 斜上 &#125; else if(c[i-1][j] &gt; c[i][j-1]) &#123; c[i][j] = c[i-1][j]; b[i][j] = 2; // 上 &#125; else if(c[i-1][j] &lt; c[i][j-1]) &#123; c[i][j] = c[i][j-1]; b[i][j] = 3; // 左 &#125; else &#123; c[i][j] = c[i-1][j]; b[i][j] = 4; // 上 或 左 &#125; &#125; &#125;&#125;// 返回动态创建的二维数组的指针int** getArr(int M,int N) &#123; int** arr = new int*[M]; for(int i=0;i&lt;M;i++) &#123; arr[i] = new int[N]; memset(arr[i],0,sizeof(int)*N); &#125; return arr;&#125;void TraceBack(string s1,string temp,int** b,int i,int j) &#123; while(i&gt;0 &amp;&amp; j&gt;0) &#123; if(b[i][j] == 1) &#123; temp = s1[i] + temp; i--; j--; &#125; else if(b[i][j] == 2) &#123; i--; &#125; else if(b[i][j] == 3) &#123; j--; &#125; else &#123; // 递归回溯 TraceBack(s1,temp,b,i-1,j); TraceBack(s1,temp,b,i,j-1); return; &#125; &#125; num ++; // 打印一次遍历得到的字符串，可能是重复的 cout&lt;&lt;"###"&lt;&lt;temp&lt;&lt;endl; // 交给 set 来移除重复字符串 setOfLCS.insert(temp);&#125; 输入 12badcdcbaabcdcdab 得到的结果为：LCS长度=5，总路径数=18，除去重复的子串后，所有LCS个数为8 可以发现：回溯过程中不同路径出现大量交叉，由于总路径数是二叉树的叶子结点数，最坏情况下，二叉树高度为max(m,n)，即两串长度最大值，叶子结点个数为2max(m,n)，这些情况中还存在大量重复，筛选很麻烦，最后结果可能得到很少的几组数据而已。 优化：矩阵搜索求所有的最长公共子序列 鉴于上述方法的缺点，根据《利用矩阵搜索求所有最长公共子序列的算法》，宫洁卿，安徽工程科技学院学报，vol23,No.4,Dec.,2008 提出的思想，这里进行简要阐述： 将 b[i][j] = 1 的点称为跳跃点，跳跃点使LCS从n→n-1(n=1,2,…,LCS长度)，LCS是由一条路径上的跳跃点对应的字符组成。将n→n-1的每个跳跃点依次找到这个点的所有下一跳跃点，直到没有下一个跳跃点为止。 矩阵搜索算法的基本思路和步骤 两个栈：第一个栈 store 用于存放所有搜索到的元素，当该栈为空时，运算结束；第二个栈 print 用于存放准备打印的元素。先计算出二维数组 C，每个节点都纪录本节点所在的坐标，LCS 长度和指向的方向。假设该 LCS 串最长为 n，那么虚拟一个( n + 1) →n的节点，该节点的坐标位于数组 C 最右下角的节点 C[ i , j ] 的右下方，为 C[ i + 1 , j + 1 ]。将该节点压入栈 store 检测栈 store 是否为空，如果为空，则本算法结束 从 store 栈顶取出一个节点压入 print 栈 如果当前的元素是边界元素1 →0 时，打印栈 print 里面除了栈底的所有元素(无须打印原本不存在的虚拟结点) 。查看 store 栈里最上面一个元素的 LCS 长度，弹出栈 print 里面所有LCS 长度比 store 栈最上面的 LCS 长度大或相等的元素，跳转到第 2 步 设该结点的 LCS 长度为 n +1，从该节点出发，查看该节点的方向箭头，按照斜方向路线、向上的路线（如果是双向的路线则走向上的路线）、向左的路线为优先级找到一个 n → ( n - 1) 的节点，假设为C[ X1 , Y1 ] 再次从该节点出发，查看该节点的方向箭头 ,按照斜方向路线、向左的路线（如果是双向的路线则走向左的路线） 、向上的路线为优先级找到一个 n →( n - 1) 的节点 ,假设为 C[ X2 , Y2 ] 比较 C[ X1 , Y1 ] 和 C[ X2 , Y2 ] 这两个节点。如果这两个结点是同一个结点，则将该结点压入栈 store，跳转到第 2 步 从刚才得到的两个结点 C[ X1 , Y1 ] 和 C[ X2 , Y2 ]，在二维数组 C 中，以 ( X1 , Y1 ) ( X2 , Y1 ) ( X1 ,Y2 ) ( X2 , Y2 ) 这四个点为坐标所构成的矩阵，在该矩阵中搜索所有的元素，将所有满足 n →( n - 1) 的节点压入栈 store。跳转到第 2 步 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;stack&gt;using namespace std;int** getArr(int,int);void LCS(int**,int**,string,string,int,int);void TraceBack(int,int,int**,int**,string);struct node &#123; int x; int y; int lcsLen; node()&#123;&#125; node(int x,int y,int z):x(x),y(y),lcsLen(z)&#123;&#125; node(int x,int y,int** c):x(x),y(y),lcsLen(c[x][y])&#123;&#125; bool operator ==(const node &amp;n) &#123; if(this-&gt;x == n.x &amp;&amp; this-&gt;y == n.y) return true; return false; &#125;&#125;;void printStack(stack&lt;node&gt;,string);void popPrint(stack&lt;node&gt;&amp;,int);node findJump(int,int,int**,int**,int);void searchMatrix(node,node,int**,int**,stack&lt;node&gt;&amp;);int main()&#123; string s1,s2; cout&lt;&lt;"Input the first Sequence:"; cin&gt;&gt;s1; cout&lt;&lt;"Input the second Sequence:"; cin&gt;&gt;s2; int len1 = s1.length()+1; int len2 = s2.length()+1; int** c = getArr(len1,len2); int** b = getArr(len1,len2); s1 = " " + s1; s2 = " " + s2; LCS(c,b,s1,s2,len1,len2); for(int i=0;i&lt;len1;i++) &#123; for(int j=0;j&lt;len2;j++) &#123; cout&lt;&lt;c[i][j]&lt;&lt;" "; if(j == len2-1) cout&lt;&lt;endl; &#125; &#125; cout&lt;&lt;"===============================\n"; for(int i=0;i&lt;len1;i++) &#123; for(int j=0;j&lt;len2;j++) &#123; cout&lt;&lt;b[i][j]&lt;&lt;" "; if(j == len2-1) cout&lt;&lt;endl; &#125; &#125; if(c[len1-1][len2-1] == 0) &#123; cout&lt;&lt;"0 0"&lt;&lt;endl; return 0; &#125; TraceBack(len1,len2,c,b,s1); return 0;&#125;int** getArr(int M,int N) &#123; int** arr = new int*[M]; for(int i=0;i&lt;M;i++) &#123; arr[i] = new int[N]; memset(arr[i],0,sizeof(int)*N); &#125; return arr;&#125;void LCS(int** c,int** b,string s1,string s2,int m,int n) &#123; for(int i=1;i&lt;m;i++) &#123; for(int j=1;j&lt;n;j++) &#123; if(s1[i] == s2[j]) &#123; c[i][j] = c[i-1][j-1] + 1; b[i][j] = 1; &#125; else if(c[i-1][j] &gt; c[i][j-1]) &#123; c[i][j] = c[i-1][j]; b[i][j] = 2; &#125; else if(c[i-1][j] &lt; c[i][j-1]) &#123; c[i][j] = c[i][j-1]; b[i][j] = 3; &#125; else &#123; c[i][j] = c[i-1][j]; b[i][j] = 4; &#125; &#125; &#125;&#125;void TraceBack(int m,int n,int** c,int** b,string str) &#123; stack&lt;node&gt; store, print; node virtualNode = node(m,n,c[m-1][n-1]+1); //由虚拟结点引发循环 store.push(virtualNode); node storeTop; int topLen,number=0; while(!store.empty()) &#123; storeTop = store.top(); store.pop(); print.push(storeTop); // 判断弹出的元素是否是边界元素 if(storeTop.x == 1 || storeTop.y == 1 || print.size() == c[m-1][n-1]+1) &#123; number++; printStack(print,str); // 是边界将print栈除虚拟结点的所有点打印 cout&lt;&lt;endl; // 数量太多不要输出这两行了 if(!store.empty()) &#123; topLen = store.top().lcsLen; popPrint(print,topLen); // 弹出小于等于store栈顶长度的print栈中的点 &#125; &#125; else &#123; //不是边界说明还有下一跳 int x = storeTop.x; int y = storeTop.y; node e1 = findJump(x-1,y-1,b,c,0); node e2 = findJump(x-1,y-1,b,c,1); if(e1 == e2) &#123; store.push(e1); &#125; else &#123; searchMatrix(e1,e2,c,b,store); &#125; &#125; &#125; cout&lt;&lt;number&lt;&lt;endl;&#125;// 输出print栈中所有元素void printStack(stack&lt;node&gt; s,string str) &#123; while(!s.empty()) &#123; cout&lt;&lt;str[s.top().x]; s.pop(); &#125;&#125;// 弹出print栈中长度小于等于n的元素，相当于回到前一跳的状态void popPrint(stack&lt;node&gt; &amp;s,int n) &#123; // 由于进入print栈点的lcsLen值是单调减，直接出栈直到lcsLen大于n，最底下的虚拟结点不能出栈 while(s.top().lcsLen &lt;= n &amp;&amp; s.size() != 1) &#123; s.pop(); &#125;&#125;// 寻找所有下一跳，type为真：遇到跳跃点向左走，type为假：遇到跳跃点向上走，直到找到第一个跳跃点node findJump(int x,int y,int** b,int** c,int type) &#123; if(type) &#123; while(b[x][y] != 1)&#123; // 这里一定有下一个跳跃点，不用担心会找不到而越界 if(b[x][y] == 2) x--; else y--; &#125; &#125; else &#123; while(b[x][y] != 1)&#123; if(b[x][y] == 3) y--; else x--; &#125; &#125; return node(x,y,c);&#125;// 如果findJump找到的两个下一跳跃点不是一个点，则以这两个点为矩形搜索里面的跳跃点，视为下一跳跃点加入store栈中void searchMatrix(node e1,node e2,int** c,int** b,stack&lt;node&gt;&amp; store) &#123; int x1 = e1.x; int y1 = e1.y; int x2 = e2.x; int y2 = e2.y; int temp; if(x1 &gt; x2) &#123; temp = x1; x1 = x2; x2 = temp; &#125; if(y1 &gt; y2) &#123; temp = y1; y1 = y2; y2 = temp; &#125; for(int i=x2;i&gt;=x1;i--) &#123; for(int j=y2;j&gt;=y1;j--) &#123; if(b[i][j] == 1) store.push(node(i,j,c)); &#125; &#125;&#125; 根据算法的思想实现了代码，经过以下数据对直接遍历和矩阵搜索进行对比： ABCDCDABCDBADCDCBADC ABCDCDABCDABCDCDABCDBADCDCBADCBADCDCBADC ABCDCDABCDABCDCDABCDABCDCDABCDBADCDCBADCBADCDCBADCBADCDCBADC ABCDCDABCDABCDCDABCDABCDCDABCDABCDCDABCDBADCDCBADCBADCDCBADCBADCDCBADCBADCDCBADC 测试用例编号 LCS长度 所有LCS个数 直接遍历循环次数 1 6 20 60 2 12 700 7560 3 18 25460 970200 4 24 936540 没测出来 当字符串长度40时，简单的遍历所有路径就无法短时间显示结果了]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Prim-Kruscal]]></title>
    <url>%2F2017%2F08%2F13%2FPrim-Kruscal%2F</url>
    <content type="text"><![CDATA[贪心算法——最小生成树 G=(V,E) 是连通带权图，E 中每条边 (v,w) 的权为 c[v][w]，G 的一个子图 G’ 是一颗包含 G 的所有顶点的树，则称 G’ 为 G 的生成树，所有生成树中权值和最小的称为 G 的最小生成树 MST 性质：设 G=(V,E) 是连通带权图，U 是 V 中的一个真子集，若存在顶点 u∈U 和顶点 v∈V-U 的边（u，v）是一条具有最小权值的边，则必存在 G 的一棵最小生成树包括这条边（u，v） Prim 和 Kruscal 都应用最小生成树的 MST 性质进行贪心选择 实例中连通带权图为 图的表示：邻接矩阵——使用二维数组存放两点之间的信息 Prim 算法 设 G=(V,E) 是连通带权图，V = {1,2,…,n} 构造 G 的最小生成树的 Prim算法的基本思想是：首先置 S={1}，然后只要 S 是 V 的真子集，就做如下贪心选择：选取满足条件 i∈S，j∈V-S，且 c[i][j] 最小的边，并将顶点 j 添加到 S 中，这个过程一直进行到 S=V为止。这个过程中选取的所有边构成 G 的一颗最小生成树 Question: 如何有效地找出满足 i∈S, j∈V-S，且权 c[i][j] 最小的边 (i,j) ? 代码说明： 对于每个 j∈V-S，closest[j] 是 j 在 S 中的临界顶点，它与 j 在 S 中的其他临接顶点 k 相比较有： c[j][closest[j]]≤c[j][k] lowest[j] 的值就是 c[j][closest[j]] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;stdio.h&gt;#define MIN 100001int Prim(int[100][100],int);int main() &#123; int N; int arr[100][100]; // 存放两点之间连线的权值 while(~scanf("%d",&amp;N)) &#123; // 输入 for(int i=0;i&lt;N;i++) &#123; for(int j=0;j&lt;N;j++) &#123; scanf("%d",&amp;arr[i][j]); &#125; &#125; // Prim printf("最小生成树权值和：%d\n",Prim(arr,N)); &#125; return 0;&#125;// lowcost[i]:V-S中点i到S中的点连线最小权值// closet[i]:V-S中点i到s中权值最小连线应该连的点坐标int Prim(int c[100][100],int N) &#123; int lowcost[N],closest[N], res=0; bool s[N]; // S 集合最开始只有0号元素时，对lowcost, clostest初始化 s[0] = true; for(int i=1;i&lt;N;i++) &#123; lowcost[i] = c[i][0]; // 最开始 S 中只有 0 closest[i] = 0; s[i] = false; &#125; // 将 V-S 集合中的元素放到 S 中 for(int i=1;i&lt;N;i++) &#123; int k, imin = MIN; for(int j=1;j&lt;N;j++) &#123; if(!s[j] &amp;&amp; lowcost[j] &lt; imin) &#123; imin = lowcost[j]; k = j; &#125; &#125; s[k] = true; printf("%d--%d \n",k,closest[k]); res += imin; // 由于 S 中有了一个新的元素，V-S 中各点 lowcost 值可能发生变化 for(int j=1;j&lt;N;j++) &#123; if(!s[j] &amp;&amp; lowcost[j] &gt; c[j][k]) &#123; lowcost[j] = c[j][k]; closest[j] = k; &#125; &#125; &#125; return res;&#125;/*Input:40 4 9 214 0 8 179 8 0 1621 17 16 0*/ Kruscal 算法 先构造一个只含 n 个顶点、而边集为空的子图，把子图中各个顶点看成各棵树上的根结点，之后，从网的边集 E 中选取一条权值最小的边，若该条边的两个顶点分属不同的树，则将其加入子图，即把两棵树合成一棵树，反之，若该条边的两个顶点已落在同一棵树上，则不可取，而应该取下一条权值最小的边再试之。依次类推，直到森林中只有一棵树，也即子图中含有 n-1 条边为止 简单的说： Kruscal 算法先找权值最小的边，检查这条边两个端点是否在一个集合中，如果不在一个集合中，连接两点(合并点所在集合)后找下一条权值最小的边；如果在一个集合，不连接两点直接找下一条权值最小的边，直到连接的边数为n-1为止 Question: 怎样按权递增的顺序查看各边？ 怎样判断两点是否在一个集合中？ 优先队列和并查集 优先队列请见 priority-queue 并查集（Union-find Sets）主要用于处理一些不相交集合 的合并问题，使用树形结构表示一个集合，树的每个节点就表示集合中的一个元素，树根作为集合的代表。 并查集的基本操作有三个： makeSet(s)：建立一个新的并查集，其中包含 s 个单元素集合。 unionSet(x, y)：把元素 x 和元素 y 所在的集合合并，要求 x 和 y 所在的集合不相交，如果相交则不合并。 find(x)：找到元素 x 所在的集合的代表，该操作也可以用于判断两个元素是否位于同一个集合，只要将它们各自的代表比较一下就可以了。在find方法中，如果每次都沿着父节点向上查找，当树很高时，会降低查找效率（时间复杂度就是树的高度）有一种非常简单而有效的策略——路径压缩： 路径压缩，就是在每次查找时，令查找路径上的每个节点都直接指向根节点 这样查看每个元素所在树的根节点只需要一步 并查集的合并：将一个集合的树根指向另一个集合的树根 ​合并策略——按秩合并：用秩表示树的高度，在合并时，总是将具有较小秩的树根指向具有较大秩的树根。简单的说，就是总是将比较矮的树作为子树，添加到较高的树中。代码中 urank[x] 表示 x 为根的树的高度 使用优先队列将边升序排列（注意对自定义类型要重写 ‘&lt;’ 运算符） 使用并查集判断两点是否在一个集合上（根节点是否相等），合并两集合 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&lt;stdio.h&gt;#include&lt;queue&gt;#define MAXSIZE 100using namespace std;int arr[MAXSIZE][MAXSIZE];int uset[MAXSIZE]; // uset[i] :元素i所属集合的根节点int urank[MAXSIZE]; // urank[i] :元素i为根节点集合的高度int Kruscal(int);int res = 0;struct Edge &#123; int x; int y; int weight; Edge(int x,int y,int weight) &#123; this-&gt;x = x; this-&gt;y = y; this-&gt;weight = weight; &#125; friend bool operator &lt; (Edge edge1, Edge edge2) &#123; return edge1.weight &gt; edge2.weight; &#125;&#125;;priority_queue&lt;Edge&gt; q;int main() &#123; int N; while(~scanf("%d",&amp;N)) &#123; res = 0; // 输入 for(int i=0;i&lt;N;i++) &#123; for(int j=0;j&lt;N;j++) &#123; scanf("%d",&amp;arr[i][j]); &#125; &#125; // 将边放入优先队列中 for(int i=0;i&lt;N-1;i++) &#123; for(int j=i+1;j&lt;N;j++) &#123; q.push(Edge(i,j,arr[i][j])); &#125; &#125; Kruscal(N); printf("%d\n",res); &#125; return 0;&#125;void makeSet(int N) &#123; // 初始时每个元素独立成为一个集合，根节点是本身，集合（树）高度为0 for(int i=0;i&lt;N;i++) &#123; uset[i] = i; urank[i] = 0; &#125;&#125;int findRoot(int x) &#123; // 只有根节点的父节点是本身 if(uset[x] == x) &#123; return x; &#125; // 不是根节点递归寻找根节点，找到后赋值给uset[x]减少下次递归的次数，相当于压缩了到根节点的路径 return uset[x] = findRoot(uset[x]);&#125;bool unionSet(int x,int y) &#123; // 取 x,y 所在集合的根节点 x=findRoot(x); y=findRoot(y); // x,y 属于一个集合，不可合并 if(x == y) &#123; return false; &#125; // x,y 不在同一集合，将高度小的集合加到高度大的集合根节点 else if(urank[x] &gt; urank[y]) &#123; // y 集合的根节点的父亲是 x 集合的根节点 uset[y] = x; &#125; else &#123; uset[x] = y; // 高度相等，x所在集合根节点接到y集合根节点，y集合高度加一 if(urank[x] == urank[y]) &#123; urank[y]++; &#125; &#125; return true;&#125;int Kruscal(int N) &#123; makeSet(N); int qsize = q.size(); int lineNum = 0; for(int i=0;i&lt;qsize;i++) &#123; // e为当前最小权值边 Edge e = q.top(); // 按权值降序处理每一条边，如果两点不在一个集合中，合并两点所在的集合返回true，说明生成了一条连线 if(unionSet(e.x, e.y)) &#123; lineNum ++; res += arr[e.x][e.y]; printf("%d--%d\n",e.x,e.y); // 连线数 = 点数 - 1 时为最小生成树，结束循环 if(lineNum == N - 1) &#123; break; &#125; &#125; q.pop(); &#125;&#125;/*Input:40 4 9 214 0 8 179 8 0 1621 17 16 0*/]]></content>
      <categories>
        <category>算法</category>
        <category>OJ 做题知识点积累</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot-mybatis小程序]]></title>
    <url>%2F2017%2F04%2F09%2Fspringboot-mybatis%2F</url>
    <content type="text"><![CDATA[IntelliJ开发SpringBoot-Mybatis应用程序新建工程 new Project——Spring Initializr 填好工程Name，包路径Group,Package Dependencies页面勾选Web，Mybatis，Mysql会自动帮你生产maven的pom文件，当然也可以自己后往里添加，maven会自动的帮你下载需要的依赖 Finish 注： maven默认中央仓库在国外可能使下载依赖很慢，可以修改maven的conf/settings.xml更换镜像地址： 123456&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 工程结构说明 main-java 目录下的 *Application 类是项目的启动类 main 下的 application.yml 是配置文件 test 是测试类的目录 pom.xml 是 maven 的依赖管理文件 配置文件配置文件有 .properties 和 .yml 两种，格式不同而已，下面的是 .yml 1234567891011121314151617181920212223242526272829303132333435363738#serverserver: port: 80#spring configspring: aop: auto: true datasource: name: * url: jdbc:mysql://localhost:3306/* driverClassName: com.mysql.jdbc.Driver username: * password: * type: com.alibaba.druid.pool.DruidDataSource maxActive: 1000 initialSize: 5 maxWait: 60000 minIdle: 1 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true maxOpenPreparedStatements: 20# MyBatismybatis: type-aliases-package: com.zjm.model mapper-locations: classpath:/mapper/*.xml configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl#PageHelperpagehelper: offsetAsPageNum: true rowBoundsWithCount: true reasonable: true 编写Mybatis 小程序准备 在上面的配置文件中 Mybatis 的配置项里 type-aliases-package：是对象类的路径 (main.java.com.*.model下) mapper-locations：是对象dao类对应的 .xml 的路径 (main.resource.mapper下) 建立以上路径及com.*.dao 在pom.xml中加入依赖：(在标签中) 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.20&lt;/version&gt;&lt;/dependency&gt; 在*Application.java文件的类上加入 @MapperScan(basePackages = “com.zjm.dao”) @SpringBootApplication 这两个注解 12345678@MapperScan(basePackages = "com.zjm.dao")@SpringBootApplicationpublic class IshopApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(IshopApplication.class, args); &#125;&#125; 代码User123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package com.zjm.model;import java.util.Date;public class User &#123; private Integer id; private String nickname; private String password; private String phone; private String email; private Date regdate; private Integer sex; private String head; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getNickname() &#123; return nickname; &#125; public void setNickname(String nickname) &#123; this.nickname = nickname == null ? null : nickname.trim(); &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password == null ? null : password.trim(); &#125; public String getPhone() &#123; return phone; &#125; public void setPhone(String phone) &#123; this.phone = phone == null ? null : phone.trim(); &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email == null ? null : email.trim(); &#125; public Date getRegdate() &#123; return regdate; &#125; public void setRegdate(Date regdate) &#123; this.regdate = regdate; &#125; public Integer getSex() &#123; return sex; &#125; public void setSex(Integer sex) &#123; this.sex = sex; &#125; public String getHead() &#123; return head; &#125; public void setHead(String head) &#123; this.head = head == null ? null : head.trim(); &#125; @Override public String toString() &#123; return "User&#123;" + "id=" + id + ", nickname='" + nickname + '\'' + ", password='" + password + '\'' + ", phone='" + phone + '\'' + ", email='" + email + '\'' + ", regdate=" + regdate + ", sex=" + sex + ", head='" + head + '\'' + '&#125;'; &#125;&#125; UserMapper12345678910111213141516171819package com.zjm.dao;import com.zjm.model.User;public interface UserMapper &#123; int deleteByPrimaryKey(Integer id); int insert(User record); int insertSelective(User record); User selectByPrimaryKey(Integer id); int updateByPrimaryKeySelective(User record); int updateByPrimaryKey(User record);&#125; UserMapper.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.zjm.dao.UserMapper"&gt; &lt;resultMap id="BaseResultMap" type="com.zjm.model.User"&gt; &lt;id column="Id" jdbcType="INTEGER" property="id" /&gt; &lt;result column="nickName" jdbcType="VARCHAR" property="nickname" /&gt; &lt;result column="password" jdbcType="VARCHAR" property="password" /&gt; &lt;result column="phone" jdbcType="VARCHAR" property="phone" /&gt; &lt;result column="email" jdbcType="VARCHAR" property="email" /&gt; &lt;result column="regDate" jdbcType="DATE" property="regdate" /&gt; &lt;result column="sex" jdbcType="INTEGER" property="sex" /&gt; &lt;result column="head" jdbcType="VARCHAR" property="head" /&gt; &lt;/resultMap&gt; &lt;sql id="Base_Column_List"&gt; Id, nickName, password, phone, email, regDate, sex, head &lt;/sql&gt; &lt;select id="selectByPrimaryKey" parameterType="java.lang.Integer" resultMap="BaseResultMap"&gt; select &lt;include refid="Base_Column_List" /&gt; from user where Id = #&#123;id,jdbcType=INTEGER&#125; &lt;/select&gt; &lt;select id="selectUserByExample" parameterType="User" resultMap="BaseResultMap"&gt; SELECT &lt;include refid="Base_Column_List" /&gt; FROM USER &lt;where&gt; &lt;if test="id != null"&gt; Id = #&#123;id&#125; &lt;/if&gt; &lt;if test="nickname != null"&gt; nickName = #&#123;nickname&#125; &lt;/if&gt; &lt;if test="password != null"&gt; password = #&#123;password&#125; &lt;/if&gt; &lt;if test="phone != null"&gt; phone = #&#123;phone&#125; &lt;/if&gt; &lt;if test="email != null"&gt; email = #&#123;email&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; &lt;delete id="deleteByPrimaryKey" parameterType="java.lang.Integer"&gt; delete from user where Id = #&#123;id,jdbcType=INTEGER&#125; &lt;/delete&gt; &lt;insert id="insert" parameterType="com.zjm.model.User"&gt; insert into user (Id, nickName, password, phone, email, regDate, sex, head) values (#&#123;id,jdbcType=INTEGER&#125;, #&#123;nickname,jdbcType=VARCHAR&#125;, #&#123;password,jdbcType=VARCHAR&#125;, #&#123;phone,jdbcType=VARCHAR&#125;, #&#123;email,jdbcType=VARCHAR&#125;, #&#123;regdate,jdbcType=DATE&#125;, #&#123;sex,jdbcType=INTEGER&#125;, #&#123;head,jdbcType=VARCHAR&#125;) &lt;/insert&gt; &lt;insert id="insertSelective" parameterType="com.zjm.model.User"&gt; insert into user &lt;trim prefix="(" suffix=")" suffixOverrides=","&gt; &lt;if test="id != null"&gt; Id, &lt;/if&gt; &lt;if test="nickname != null"&gt; nickName, &lt;/if&gt; &lt;if test="password != null"&gt; password, &lt;/if&gt; &lt;if test="phone != null"&gt; phone, &lt;/if&gt; &lt;if test="email != null"&gt; email, &lt;/if&gt; &lt;if test="regdate != null"&gt; regDate, &lt;/if&gt; &lt;if test="sex != null"&gt; sex, &lt;/if&gt; &lt;if test="head != null"&gt; head, &lt;/if&gt; &lt;/trim&gt; &lt;trim prefix="values (" suffix=")" suffixOverrides=","&gt; &lt;if test="id != null"&gt; #&#123;id,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="nickname != null"&gt; #&#123;nickname,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="password != null"&gt; #&#123;password,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="phone != null"&gt; #&#123;phone,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="email != null"&gt; #&#123;email,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="regdate != null"&gt; #&#123;regdate,jdbcType=DATE&#125;, &lt;/if&gt; &lt;if test="sex != null"&gt; #&#123;sex,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="head != null"&gt; #&#123;head,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;/trim&gt; &lt;/insert&gt; &lt;update id="updateByPrimaryKeySelective" parameterType="com.zjm.model.User"&gt; update user &lt;set&gt; &lt;if test="nickname != null"&gt; nickName = #&#123;nickname,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="password != null"&gt; password = #&#123;password,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="phone != null"&gt; phone = #&#123;phone,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="email != null"&gt; email = #&#123;email,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="regdate != null"&gt; regDate = #&#123;regdate,jdbcType=DATE&#125;, &lt;/if&gt; &lt;if test="sex != null"&gt; sex = #&#123;sex,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="head != null"&gt; head = #&#123;head,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;/set&gt; where Id = #&#123;id,jdbcType=INTEGER&#125; &lt;/update&gt; &lt;update id="updateByPrimaryKey" parameterType="com.zjm.model.User"&gt; update user set nickName = #&#123;nickname,jdbcType=VARCHAR&#125;, password = #&#123;password,jdbcType=VARCHAR&#125;, phone = #&#123;phone,jdbcType=VARCHAR&#125;, email = #&#123;email,jdbcType=VARCHAR&#125;, regDate = #&#123;regdate,jdbcType=DATE&#125;, sex = #&#123;sex,jdbcType=INTEGER&#125;, head = #&#123;head,jdbcType=VARCHAR&#125; where Id = #&#123;id,jdbcType=INTEGER&#125; &lt;/update&gt;&lt;/mapper&gt; 测试类进入UserMapper.java，右键——Go to—— Test——Create new test 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.zjm.dao;import com.zjm.model.User;import com.zjm.util.MD5;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import java.util.Date;import static org.junit.Assert.*;/** * Created by ZJM on 2017/4/5. */@SpringBootTest@RunWith(SpringJUnit4ClassRunner.class)public class UserMapperTest &#123; @Autowired private UserMapper userMapper; @Test public void deleteByPrimaryKey() throws Exception &#123; userMapper.deleteByPrimaryKey(2); &#125; @Test public void insert() throws Exception &#123; User user = new User(); user.setPhone("13636662259"); user.setSex(0); user.setEmail("7788521@qq.com"); user.setNickname("zjm"); user.setPassword("123456"); user.setRegdate(new Date()); userMapper.insert(user); &#125; @Test public void insertSelective() throws Exception &#123; &#125; @Test public void selectByPrimaryKey() throws Exception &#123; User user = userMapper.selectByPrimaryKey(1); System.out.println(user); &#125; @Test public void updateByPrimaryKeySelective() throws Exception &#123; User user = new User(); user.setId(1); user.setNickname("shaunHaHaHa"); userMapper.updateByPrimaryKeySelective(user); &#125; @Test public void updateByPrimaryKey() throws Exception &#123; &#125; @Test public void selectUserByExample() throws Exception &#123; User user = new User(); user.setPassword("123456"); System.out.println(userMapper.selectUserByExample(user)); &#125;&#125; 点击方法旁边的绿色按钮运行就行了 发请求测试上面的是 JUnit 的单元测试，现在用发请求的方式从服务器获取响应 正常需要在controller和mapper中间建立service层，这里示例业务简单，简化省去了service层，正式的项目中再加上 新建controller 在com.*.controller下新建UserMS.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.zjm.controller;import com.sun.javafx.collections.MappingChange;import com.zjm.dao.UserMapper;import com.zjm.model.User;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.servlet.http.HttpServletResponse;import java.util.HashMap;import java.util.List;import java.util.Map;/** * Created by ZJM on 2017/4/8. */@RestController@RequestMapping("/user")public class UserMS &#123; @Autowired private UserMapper userMapper; @RequestMapping("add") public User add(User user) &#123; userMapper.insert(user); return user; &#125; @RequestMapping("delete") public Map&lt;String,Object&gt; delete(int id) &#123; Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;(); boolean isOk = true; try &#123; userMapper.deleteByPrimaryKey(id); &#125; catch (Exception e) &#123; e.printStackTrace(); isOk = false; &#125; map.put("status",isOk); return map; &#125; @RequestMapping("update") public User update(User user) &#123; userMapper.updateByPrimaryKeySelective(user); return user; &#125; @RequestMapping("findUserById") public User findUserById(int id) &#123; return userMapper.selectByPrimaryKey(id); &#125; @RequestMapping("findUserByExample") public List&lt;User&gt; findUserByExample(User user) &#123; return userMapper.selectUserByExample(user); &#125;&#125; 运行*Application.java文件点击绿色三角，即可启动 IntelliJ 自带的 tomcat，按照配置的服务名及端口访问吧 发请求安装postman或者浏览器发送请求 eg 1234http://localhost:8080/user/findUserById?id=1http://localhost:8080/user/findUserByExample?sex=1http://localhost:8080/user/delete?id=5http://localhost:8080/user/update?id=6&amp;nickname=小王 要是用浏览器发post请求还得写表单，post请求就用 postman 发吧 到此一个简单的例子就可以运行了]]></content>
      <categories>
        <category>Project</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>IntelliJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos下安装jdk和Tomcat]]></title>
    <url>%2F2017%2F03%2F05%2Finstall-jdk-tomcat%2F</url>
    <content type="text"><![CDATA[用yum安装jdk查看 yum 库中都有哪些 jdk 版本（暂时只发现了 openjdk）yum search java|grep jdk 安装yum install java-1.7.0-openjdk 设置环境变量在profile文件中添加如下内容： 1234567#set java environmentJAVA_HOME=/usr/lib/jvm/java-1.7.0-openjdk-1.7.0.131#复制路径以防路径无法找到JRE_HOME=$JAVA_HOME/jreCLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/libPATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/binexport JAVA_HOME JRE_HOME CLASS_PATH PATH 让修改生效 source /etc/profile 验证java -version 安装Tomcat使用wget命令：wget -c http://apache.fayea.com/tomcat/tomcat-8/v8.5.11/bin/apache-tomcat-8.5.11.tar.gz 解压tar -zxvf apache-tomcat-8.5.11.tar.gz 启动进入解压后的apache-tomcat-8.5.11 -- bin目录，执行命令： ./startup.sh 检查能否访问如果不能访问，可能是防火墙问题： 关闭防火墙： service firewalld stop 在iptables里添加开放 8080 端口： -A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT 将iptables服务重启： service iptables restart]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos下安装mysql]]></title>
    <url>%2F2017%2F03%2F05%2Finstall-mysql%2F</url>
    <content type="text"><![CDATA[yum 安装yum install -y mysql-server mysql mysql-devel 启动服务service mysqld start 给root用户设置密码mysqladmin -u root password &#39;your password&#39; 登录mysql -u root -p 查看并更改字符集show variables like &#39;character%&#39;; 关闭mysql服务 service mysqld stop 修改my.cnf文件 12345678910111213141516171819202122[mysqld]default-character-set = utf8 #这个是我添加的character_set_server=utf8 #这个是我添加的init_connect='SET NAMES utf8'datadir=/var/lib/mysqlsocket=/var/lib/mysql/mysql.sockuser=mysqlsymbolic-links=0 [mysqld_safe]default-character-set = utf8 #这个是我添加的log-error=/var/log/mysqld.logpid-file=/var/run/mysqld/mysqld.pid [client]default-character-set = utf8 #这个是我添加的 [mysql.server]default-character-set = utf8 #这个是我添加的 [mysql]default-character-set = utf8 #这个是我添加的 重启服务service mysqld restart 查看监听端口netstat -anp mysql数据库绑定的默认端口号是 3306 用本地可视化工具连接服务器数据库在服务器端进入mysql服务，执行： 12grant all privileges on *.* to &apos;root&apos;@&apos;%&apos; identified by &apos;your password by root&apos;;flush privileges; 在本地即可登录访问]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[priority_queue]]></title>
    <url>%2F2017%2F02%2F06%2Fpriority-queue%2F</url>
    <content type="text"><![CDATA[STL priority_queue 优先队列在优先队列中，优先级高的元素先出队列 class template std::priority_queue1234template &lt;class T, class Container = vector&lt;T&gt;, class Compare = less&lt;typename Container::value_type&gt; &gt; class priority_queue; Priority queuePriority queues are a type of container adaptors, specifically designed such that its first element is always the greatest of the elements it contains, according to some strict weak ordering criterion.This context is similar to a heap, where elements can be inserted at any moment, and only the max heapelement can be retrieved (the one at the top in the priority queue).Priority queues are implemented as container adaptors, which are classes that use an encapsulated object of a specific container class as its underlying container, providing a specific set of member functions to access its elements. Elements are popped from the “back” of the specific container, which is known as the top of the priority queue. The standard container classes vector and deque fulfill these requirements. By default, if no container class is specified for a particular priority_queue class instantiation, the standard container vector is used.Support of random access iterators is required to keep a heap structure internally at all times. This is done automatically by the container adaptor by automatically calling the algorithm functions make_heap, push_heap and pop_heap when needed. Template parameters T Type of the elements.Aliased as member type priority_queue::value_type. Container Type of the internal underlying container object where the elements are stored.Its value_type shall be T.Aliased as member type priority_queue::container_type. Compare A binary predicate that takes two elements (of type T) as arguments and returns a bool.The expression comp(a,b), where comp is an object of this type and a and b are elements in the container, shall return true if a is considered to go before b in the strict weak ordering the function defines.The priority_queue uses this function to maintain the elements sorted in a way that preserves heap properties (i.e., that the element popped is the last according to this strict weak ordering).This can be a function pointer or a function object, and defaults to less, which returns the same as applying the less-than operator (`a). 小结： priority_queue 将其中的元素默认按照从大到小排列 默认声明：priority_queue&lt; T , vector , less &gt; q; 默认声明可省略为：priority_queue q; 声明为从小到大：priority_queue&lt; T , vector , greater &gt; q; 如果T是自定义类型，则必须重载operator&lt; eg123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;struct Student &#123; string name; int score; Student(string name,int score) &#123; this-&gt;name = name; this-&gt;score = score; &#125; friend bool operator &lt; (Student stu1,Student stu2) &#123; return stu1.score &lt; stu2.score; &#125;&#125;;int main()&#123; Student stu[3] = &#123; Student("Tom",80), Student("Jerry",100), Student("Marry",90) &#125;; priority_queue&lt;Student&gt; q; for(int i=0;i&lt;3;i++) &#123; q.push(stu[i]); &#125; cout&lt;&lt;q.size()&lt;&lt;endl; for(int i=0;i&lt;3;i++) &#123; Student s = q.top(); cout&lt;&lt;s.name&lt;&lt;", "&lt;&lt;s.score&lt;&lt;endl; q.pop(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OJ 做题</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Share~]]></title>
    <url>%2F2017%2F01%2F24%2Fky%2F</url>
    <content type="text"><![CDATA[分享给朋友的Dear Mao Shuo: 你看历年分数线先给自己各科定个小目标，100+100+50+50啊，关注几个老师的微博，微信公众号：蒋中挺，何凯文，张宇，刘一男……都会有免费的直播，何凯文还有每日一句，有时间就看，没时间就算了别当负担，我每日一句就跟了一阵。直播课感觉蒋中挺的挺好的，还有回放，英语数学我都没咋听，不过我还是推荐听。我学的时间里有效的部分太少了：早上九点开始，两个半小时去吃饭，中午ZZZ，下午两点开始，三个小时又吃饭，晚上六点开始，四个小时回寝，一天最多十个小时的学习时间，真正有收获的没多少。。。我九月份还报了文都的秋季班（补暑假课程的班），因为我暑假有实训。文都的课好也不好，为了赶进度，有时一天看十个多小时的视频。往往一天下来很累了，回来就没有把一天的课进行总结整理笔记。我有一次整理了一次，花了很多时间，因为课上的内容太多，老师说的很快，好多听不懂的需要课后自己整理复习，如果没有总结复习，那课久了回看笔记就看不懂了，还会越堆越多。所以，不及时总结复习，课就等于白上，还浪费大量的时间和精力。 其实还是自己总结最重要了，看视频，做题，再多，自己不理解归纳总结知识点，意义都不大。做题我有一招特别好使，如果你知道这道题考的考点是什么，你一定能做对。所以，数学背笔记时一定要背考点，12345… 复习计划早制定，专业课早开始，政治选择早开始，真的不是很难，别害怕，就是路漫漫修远，坚持下来不容易。 如果我调剂不到好的学校，就做研友；复试通过，就给你书… Good luck Shaun]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法小结]]></title>
    <url>%2F2017%2F01%2F23%2Fsort%2F</url>
    <content type="text"><![CDATA[数据结构排序算法时空稳 分类 排序方法 平均情况(时) 最坏(时) 最好(时) 空间复杂度 稳定性 插入 直接插入 O(n*n) O(n*n) O(n) O(1) 稳 折半插入 O(n*n) O(1) 稳 希尔 O(nlogn) O(nlogn) O(1) 不稳 交换 冒泡 O(n*n) O(n*n) O(n) O(1) 稳 快速 O(nlogn) O(n*n) O(nlogn) O(logn) 不稳 选择 简单选择 O(n*n) O(n*n) O(n*n) O(1) 不稳 堆排 O(nlogn) O(nlogn) O(nlogn) O(1) 不稳 其他 归并 O(nlogn) O(nlogn) O(nlogn) O(n) 稳 基数 O(d(n+r)) O(d(n+r)) O(d(n+r)) O(r) 稳 小口诀 基于基本排序算法 时间复杂度按平均算 @马士兵老师 冒泡选择插入堆，快速希尔计基堆归并O(n)快logn，其他空间都是1快堆归并nlogn，插折冒选慢n方（平均时间）希尔特殊1.3，基数d把两数加（平均时间）希尔快选堆不稳，其他排序稳稳哒 注： log 的 g 不发音 第二句空间复杂度，三四句时间 ​ ​ ​]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git基本操作]]></title>
    <url>%2F2017%2F01%2F15%2FGit%2F</url>
    <content type="text"><![CDATA[Git 是目前最流行的版本管理系统 Windows系统安装和使用安装后会出现三个工具-Bash,-CMD,-GUI，只用-Bash就行 在你想作为本地仓库的文件夹上（或进入文件夹空白处）鼠标右键，选择Git Bash here 常用命令git clone​ 从远程主机复制文件到本地文件夹 1$ git clone &lt;链接&gt; &lt;本地路径&gt; ​ &lt;本地路径&gt;省略即-Bash当前路径 git remote 管理远程主机名：Git要求每个远程主机都必须指定一个主机名 添加远程主机+命名 1$ git remote add &lt;主机名&gt; &lt;网址&gt; 列出所有远程主机 12$ git remoteorigin 查看远程主机名对应的网址 123$ git remote -vorigin https://... (fetch)origin https://...(push) 删除主机 1$ git remote rm &lt;主机名&gt; 改主机名 1$ git remote rename &lt;原主机名&gt; &lt;新主机名&gt; git fetch 远程主机有更新（commit），将更新的取回本地。默认情况下git fetch 取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名。 1$ git fetch &lt;远程主机名&gt; &lt;分支名&gt; eg 1$ git fetch origin master 查看远程分支 123456$ git branch -rorigin/master #查看远程分支$ git branch -a #查看所有分支（包括本地）* master remotes/origin/master 在本地分支上合并远程分支 1$ git merge origin/master git pull 取回远程主机某分支的更新，并与本地的制定分支合并 1$ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 与当前分支合并冒号后可省略 eg 1$ git pull origin master 相当于 12$ git fetch origin$ git merge origin/master git push 将本地分支的更新，推送到远程主机 1$ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; eg 123$ git push origin master:master#等同于$ git push origin master 如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。 上面命令表示，将本地的master分支推送到origin主机的master分支。 省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支 123$ git push origin :master# 等同于$ git push origin --delete master 上面命令表示删除origin主机的master分支 更详细资料请参照：https://www.git-scm.com/book/en/v2]]></content>
      <categories>
        <category>版本控制</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开篇]]></title>
    <url>%2F2017%2F01%2F13%2FBegin%2F</url>
    <content type="text"><![CDATA[自序​ 大家好，我是一个普通的大学生，2013年考入哈尔滨工程大学软件工程专业，2017年想写博客，已经24岁。人生正在紧要关口，大的决策呼之欲出。 ​ 现在的我，放假在家，感到有属于自己的时间无比宝贵，没有外事打扰，想干什么就干什么，以后怕是少有了，无比珍惜。每天能做自己喜欢做的事，玩也好，学也好，不必担心衣食住行，真是最后的天堂了。 ​ 想把自己的收获、乐趣、心得，想法通过网站向有缘来访的朋友分享，留住生命中的点滴。 ​ 这两天为了建一个博客站，忙来忙去找了很多资料，问了很多朋友。总算有了点成果，虽然就是读说明书，还是很费劲，遇到的问题层出不穷……我觉的程序员最宝贵的能力就是自学能力，敢于接触新鲜事物，读懂别人的文章，英文开发文档，自己把新技术掌握了，并有自己的理解。 ​ 现在的我还差很多，希望在朋友的帮助下，师长的指导下，一点一点的，不断进步。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
</search>
