<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[word2vec的简单理解]]></title>
    <url>%2F2019%2F03%2F19%2Fword2vec%2F</url>
    <content type="text"><![CDATA[word2vec研究如何将词用向量表示，使用的两个重要模型——CBOW模型(Continuous Bag-of-Words Model)和Skip-gram模型(Continuous Skip-gram Model)，CBOW通过上下文预测中间词，Skip-gram对中间词预测它的上下文，本文只对CBOW进行介绍 词的向量表示 one-hot：语料库的词项个数为m，则one-hot表示的长度为m，只有一个位置是1，其余都是0 distributed representation：假设每个词项有d个特征，d远小于m，用d维向量表示每个词项 CBOW CBOW 是 word2vec 中使用的浅层神经网络模型，语料库中词项和词项的上下文做为样本，Sample(Context(x), x)，对模型的参数进行训练，得到每个词项的向量表示。 词的上下文 Context(x) 一个词出现的概率只与它前后固定数目(m)的词相关，n的取值与模型参数有关，可以参考： n 模型参数数量 1 2*10^5 2 4*10^{10} 3 8*10^{15} 4 16*10^{20} 例子：我很爱学信息检索 如果n=2，则学的上下文Context(学)={ 很，爱，信息，检索 } 4 个词组成 模型结构 输入层 上下文词项的one-hot 隐藏层 对于一个样本Sample(Context(x), x)，将u_i的one-hot向量与表示矩阵W_{m*d}相乘，得到u_i的当前表示向量\hat{u_i}，u_i\in Context(x)，将\sum_{i=1}^{2n}{\hat{u_i}}/2n做为隐藏层的输出，是一个1*d的向量。 输出层 隐藏层得到的1d向量与权重矩阵W'相乘，得到1\m的向量，通过softmax处理后得到一个1*m的向量\hat{y}，为中间词出现的概率，概率最大的index指向的词项即为预测出的中间词，与真实值的one-hot向量 y 做比较，根据误差更新权重矩阵W与W'。 softmax( \begin{bmatrix} 4.01 & 2.01 & 5& 3.34& 1.2 \end{bmatrix} )= \begin{bmatrix} 0.23&0.03&0.61&0.12&0.01 \end{bmatrix}损失函数 L=H(\hat y,y)=-\sum_x{p(x)logq(x)} 梯度下降更新W和W'，训练完毕后，W矩阵即为词向量矩阵，用一个词项的one-hot去乘W矩阵即得到这个词项的词向量 结构分析 参数数量：2*d*m个，d为词向量长度，m为词项个数，在语料库中m的值是很大的，对于一个样本(Context(x), x)，只有一个是正确的结果，其余的m-1个全是错误的结果，每次都对大量的错误结果进行权重更新是很耗时的 改进思路：减少网络的参数个数和每次要更新的参数个数 负采样策略 对于词 w 的上下文Context(w)来预测w，Context(x)与x构成了一个正样本，Context(x)与别的词项就构成负样本，每次训练仅选择一小部分的负样本，对他们连接的权重进行更新，减少了每次训练需要更新的权重数量，应该选择多少，如何进行选择呢？大体思路是让出现频率高的词项更大概率被选做负样本。 采样率公式： len(w)=\frac{[counter(w)]^{3/4}}{\sum_{u\in D}[counter(u)]^{3/4}}len(w)表示w应该被保留作为负样本的概率，counter(w)代表w在语料库中出现的次数，指数3/4是经验值 Hierarchical softmax的CBOW 分层softmax的CBOW将输出层改为树形结构 建立哈夫曼树，使高频词项更靠近根节点，规定左孩子为负类，右孩子为正类，经过一个非叶子结点做了一次二分类，设隐藏层的输出为x，经过每个非叶子结点被分到正类的概率为： \sigma(x^T\theta)=\frac{1}{1+e^{-x^T\theta}}分到负类概率为：1-\sigma(x^T\theta)，每个非叶子结点上都有一个待定参数向量：\theta，可以计算出到达值为1的结点x的概率： 第1次：p(0|x,\theta_1)=1-\sigma(x^T\theta_1)\\ 第2次：p(1|x,\theta_2)=\sigma(x^T\theta_2)\\ 第3次：p(1|x,\theta_3)=\sigma(x^T\theta_3)\\ 第4次：p(1|x,\theta_4)=\sigma(x^T\theta_4)\\ 即：p(x|Context(x))=\prod_{i=1}^4{p(d_i|x,\theta_i)},\ d_i\in\{0,1\}目标函数：L=\sum_{x\in C}{log\ p(x|Context(x))} 最大化，通过梯度上升（或者求 1-L 的最小值，用梯度下降）更新 x 和 \theta​ 的值，表示矩阵是最终得到的词向量矩阵。 参考文献Efficient Estimation of Word Representations in Vector Space word2vec的数学原理 word2vec的负采样]]></content>
      <categories>
        <category>mechine learning</category>
      </categories>
      <tags>
        <tag>word2vec</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis 主从服务器搭建与哨兵机制]]></title>
    <url>%2F2019%2F03%2F12%2Fredis-master-slave-sentinel%2F</url>
    <content type="text"><![CDATA[实验内容：用三台服务器运行 redis，设置主从关系进行数据存储，建立哨兵监督主节点，模拟主节点宕机后的哨兵选举新主 Redis 单节点安装 将 Redis 5.0.3压缩包解压，进入解压后的文件夹，可以看到Makefile文件，在这个路径下执行make&amp;&amp;make PREFIX=~/redis install进行编译和安装，在~/redis下可以看到bin文件夹，里面有一些脚本文件：redis-server，redis-cli，redis-sentinel等。配置环境变量使得执行脚本命令更加方便：vi /etc/profile在最后加上如下内容：(shift + g跳到最后一行，shift + $跳到一行的最后) 12export REDIS_HOME=/root/redisPATH=$PATH:$REDIS_HOME/bin 在单节点上的某个路径上运行redis-server即可按默认参数（端口6379）启动服务，redis-cli作为客户端访问服务，可以用形如：redis-server --port 6380，redis-cli -h ip -p port的方式指定参数，具体命令访问redis官网 Redis 集群搭建 创建三个服务器： 192.168.56.100 master 192.168.56.101 slave1 192.168.56.102 slave2 vim /etc/hosts设置ip对应的域名减少敲ip的麻烦 为了方便，以下都在各个服务器的~/redis/6380文件夹下操作 主结点 master为主节点，服务配置文件vi redis.conf： 12port 6380protected-mode no 哨兵配置文件vi sent.conf： 12port 26379sentinel monitor c1 master 6380 2 启动服务：redis-server redis.conf 启动哨兵：redis-sentinel sent.conf 从结点 slave1 和 slave2 作为从节点，在服务配置上加上附属主节点，在哨兵上没有不同 123port 6380protected-mode noslaveof master 6380 写好配置文件后启动服务和哨兵 实验内容 通过客户端访问不同结点：redis-cli -h master -p 6380可以执行set/get操作，访问slave结点只能执行get操作 模拟主节点宕机：使用Ctrl C命令关闭主节点redis服务进程，查看slave1和slave2 的状态，可以发现经过大约10s后哨兵重新选举slave1或者slave2作为新的主，同时将master降级为slave，再启动master的redis服务时，它以从节点的身份加入集群。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[枫叶城]]></title>
    <url>%2F2019%2F02%2F13%2Ffyl%2F</url>
    <content type="text"><![CDATA[最近，开始练习杨昊昆的枫叶城，这首用到打板和拍弦的技巧十足需要练习一阵子。深秋的城中，枫叶在枝头，在风中，在地面，映红了这座城，在城楼高处，吉他的旋律，伴着起舞的枫叶，在簌簌的风中回荡，在寂静的空巷中飘扬。这，显然是一个人的城。这首曲子真的好听，弹琴的时候，才是我全身心投入的时候，只想沉浸在音乐中，全部的烦恼也都无暇顾及。做别的事呢，则经常是插着耳机，朋友笑着说，你真的很喜欢音乐啊。是啊，但是，不听歌做什么呢？在校园里用眼睛和腿就可以过马路，食堂吃饭只需要嘴巴，在电脑前工作音乐能让枯燥的时间过的快些。当旋律响起，枫叶出现在空中，走在古城中，青石板铺成的宽阔街道上，两侧空无一人的店铺，静止的门窗，时隐时现的风铃，也不觉得奇怪。朋友冲我笑了笑：来啦，我也向他问好，走到座位上，把耳机从手机上拔下，插在了电脑上。不知从什么时候开始，就喜欢把情绪埋在心底，脸上的表情也越来越少，即使在家里，和一年见几次面的父母，也不想让他们看出自己的喜怒哀乐。…喧嚣和嘈杂中，有能属于自己的安静，是多么珍贵，把寝室的窗户擦亮，静下心观察天空的颜色，远处高山的秋装，为自己能生活在温暖的室内而惬喜。嘴上说着要为自己活，要有独立的人格，可漫漫长夜，谁又能忍受得了呢。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F01%2F28%2Ftensorflow-method%2F</url>
    <content type="text"><![CDATA[tf.random_uniform tf.random_uniform(shape, minval, maxval, dtype, seed, name) 产生3行4列的随机数，范围在(-1, 1)，类型是float32，可用于权重参数的初始化 1tf.random_uniform((3, 4), -1, 1, dtype=tf.float32) tf.argmax tf.arg_max(input, dimension, output_type=tf.int64, name=None) 给出某个tensor对象在某一维上的其数据最大值的索引值 12345678arr = np.array([ [1, 2, 3], [2, 3, 4], [5, 4, 3], [8, 7, 2]])tf.argmax(test, 0) # array([3, 3, 1])tf.argmax(test, 1) # array([2, 2, 0, 0]) tf.reduce_mean1234x = tf.constant([[1., 1.], [2., 2.]])tf.reduce_mean(x) # 1.5, axis=None，对所有数字tf.reduce_mean(x, 0) # [1.5, 1.5],axis=0tf.reduce_mean(x, 1) # [1., 2.],axis=1 tf.reduce_sum1234x = tf.constant([[1., 1.], [2., 2.]])tf.reduce_sum(x) # 6.0, axis=None，对所有数字tf.reduce_sum(x, 0) # [3., 3.], axis=0tf.reduce_sum(x, 1) # [2., 4.], axis=1 tf.truncated_normal tf.truncated_normal(shape,mean=0.0, stddev=1.0, dtype=tf.float32, seed=None, name=None) 从截断的正态分布中输出形如 shape 的随机值：生成 (μ-2σ，μ+2σ) 之间的随机数 tf.random_normal tf.random_normal(shape, mean=0.0, stddev=1.0, dtype=tf.float32, seed=None, name=None) 按正太分布(μ,σ)生成形如 shape 的随机数 tf.constant tf.constant(value, dtype=None, shape=None, name=&#39;Const&#39;, verify_shape=False) 产生形如 shape 的常量 Tensor，可用于多偏执量初始化 tf.cast tf.cast(x, dtype, name=None) 将 x 的数据类型转成 dtype 123456a = tf.Variable([1, 0, 0, 1])b = tf.cast(a, dtype=tf.bool)with tf.Session() as sess: sess.run(tf.initialize_all_variables()) print(sess.run(b))# [True False False True] tf.nn.conv2d 卷积函数 tf.nn.conv2d(input, filter, strides, padding, use_cudnn_on_gpu=None, name=None) input: 要做卷积的输入图像，类型：Tensor [batch, in_height, in_width, in_channels]，含义：[训练一批 batch 个的图片，图片高度，宽度，颜色通道数]； filter: 卷积核，类型：Tensor [filter_height, filter_width, in_channels, out_channels]，含义：[卷积核高度，宽度，颜色通道数，卷积核个数] strides: 步长，一维Tensor，长度4，二维图片是[1, stride, stride, 1] padding: 类型: String，’SAME’ 或 ‘VALID’ 其中之一，’SAME’检测图像边缘，’VALID’不检测图像边缘 use_cudnn_on_gpu: 类型：bool，是否用 cudnn 加速，默认是 true Return: 返回值类型：feature map: Tensor [batch, height, width, channels] 123456789101112131415i = tf.Variable([[ [[1.], [2.], [3.]], [[2.], [1.], [0.]], [[0.], [3.], [0.]]]])j = tf.Variable([[ [[1.]], [[2.]]], [[[3.]], [[2.]]]])sess = tf.InteractiveSession()sess.run(tf.global_variables_initializer())op = tf.nn.conv2d(i, j, strides=[1, 1, 1, 1], padding='VALID')print(sess.run(op))# [[ [[13.] [11.]] # [[10.] [10.]] ]] tf.nn.max_pool 最大池化层 tf.nn.max_pool(value, ksize, strides, padding, name=None)，用于对卷积层输出的 featrue map 提取局部最大值 value: 池化层的输入；类型：feature map: Tensor [batch, height, width, channels]是卷积层的输出 ksize: 池化窗口的大小，四维向量，一般是 [1, height, width, 1] strides: 步长，[1, stride, stride, 1] padding: ‘VALID’ or ‘SAME’ return: Tensor，[batch, height, width, channels] 1234567891011i = tf.Variable([[ [[1.], [2.], [3.]], [[2.], [1.], [0.]], [[0.], [3.], [0.]]]])sess = tf.InteractiveSession()sess.run(tf.global_variables_initializer())op = tf.nn.max_pool(i, [1, 2, 2, 1], [1, 1, 1, 1], padding='VALID')print(sess.run(op))# [[ [[2.] [3.]]# [[3.] [3.]] ]] tf.nn.avg_pool 对 feature_map 提取局部均值 tf.nn.softmax tf.nn.softmax(logits, axis=None, name=None) 激活函数，将N*1的向量归一化为 (0, 1) 之间的值，将较大的量特征更加明显 logits: 非空 Tensor axis: 执行 softmax 的维度，默认是 -1，即最后一个维度 123456i = tf.Variable([1., 2., 3., 4.])with tf.Session() as sess: sess.run(tf.global_variables_initializer()) op = tf.nn.softmax(i) print(sess.run(op))# [0.0320586 0.08714432 0.23688284 0.6439143 ] tf.matmul tf.matmul(a, b, transpose_a=False, transpose_b=False, adjoint_a=False, adjoint_b=False, a_is_sparse=False, b_is_sparse=False, name=None) 矩阵乘法：a, b 必须是矩阵(维度大于2)，都可以通过相应参数进行转置或共轭，可以使用稀疏矩阵乘法提高效率 1234567891011121314i = tf.Variable([ [1, 2], [2, 3]])j = tf.Variable([ [2, 3], [1, 2]])with tf.Session() as sess: sess.run(tf.global_variables_initializer()) op = tf.matmul(i, j) print(sess.run(op))#[ [4 7]# [7 12] ] tf.multiply tf.math.multiply(x, y, name=None) x, y 对应位置值相乘 12345678910i = tf.Variable([1, 2])j = tf.Variable([ [2, 1], [1, 3]])with tf.Session() as sess: sess.run(tf.global_variables_initializer()) print(sess.run(tf.multiply(i, j)))# [[2 2]# [1 6]] tf.reshape tf.reshape(tensor, shape, name=None) 变形，-1 可以用来推测形状：[-1] 可以用来展开，[-1, 3]：分成 x 组，每组 3 个，[2, -1]：分成 2 组，每组 x 个 tf.nn.relu tf.nn.relu(features, name=None)激活函数，即 max(features, 0)，将矩阵中每行的负数置 0 12345i = tf.Variable([-1, 1, 2, -2])with tf.Session() as sess: sess.run(tf.global_variables_initializer()) print(sess.run(tf.nn.relu(i)))# [0 1 2 0] tf.nn.dropout tf.nn.dropout(x, keep_prob, noise_shape=None, seed=None, name=None) 防止过拟合，一般用在全连接层，随机扔掉一部分神经元。让神经元按激活值 keep_prob 活跃还是睡眠。 x：输入 keep_prob：神经元被选中的概率，初始化 keep_prob 是一个占位符，keep_prob=tf.placeholder(tf.float32) train 的时候使用 dropout cross_entropy 交叉熵： H(p,q)=-\sum_xp(x)logq(x)p(x)是样本的标签，q(x)是模型的预估结果 由来：交叉熵 - 样本熵(常数) = 相对熵 或 KL散度 H(p,q)-H(p)=-\sum_x p(x)logq(x)+\sum_x p(x)logp(x)=\\-\sum_x p(x)(logq(x)-p(x))=-\sum_x p(x)log \frac{q(x)}{p(x)}cross_entropy = -tf.reduce_sum(y_ * tf.log(y_conv)) 其中，y_是样本 label，y_conv 是模型的输出 feed_dict 替换图中的某个 tensor 的值，可以用来设计图的输入 (替换开始声明的占位符) 123op = tf.multiply(a, 3)with tf.Session() as sess: sess.run(op, feed_dict=&#123;a: 5&#125;) # 将 a=5传给操作op tf.SparseTensor 稀疏张量：SparseTensor(indices, values, dense_shape)，即坐标，值，规模 1234SparseTensor(indices=[[0, 0], [1, 2]], values=[1, 2], dense_shape=[3, 4])[[1, 0, 0, 0] [0, 0, 2, 0] [0, 0, 0, 0]] tf.trace 计算矩阵的迹：主对角线的总和 12x = tf.constant([[1,2,3],[4,5,6],[7,8,9]])tf.trace(x) # 15]]></content>
      <categories>
        <category>tensorflow</category>
      </categories>
      <tags>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[skip-gram]]></title>
    <url>%2F2018%2F12%2F16%2Fskip-gram%2F</url>
    <content type="text"><![CDATA[如何将一个词用向量表示呢？本文介绍我对word2vec的简单理解 预备知识sigmoid 函数 二分类的激活函数： \delta(x) = \frac{1}{1+e^{-x}}性质：值域 (0, 1) \delta'(x) = \delta(x)[1-\delta(x)]\\ [log\delta(x)]' = 1-\delta(x)\qquad [log(1-\delta(x))]'=-\delta(x) 逻辑回归 logistic回归，一种广义线性回归，解决二分类问题：{(xi, yi)}im 为二分类问题的样本数据，其中 xi∈Rn，yi∈{0, 1} 由sigmoid函数，对任意样本 x=(x1, x2,…, xn)T，可将二分类问题的假设函数(hypothesis)写成 h_\theta(x)=\delta(\theta_0+\theta_1x_1+\theta_2x_2+...+\theta_nx_n)其中 θ=(θ0,θ1,…,θn)T为待定参数，将x扩展为起始位置添加x0=1，则 h_\theta(x)=\delta(\theta^Tx)=\frac{1}{1+e^{-\theta^Tx}}去阈值T=0.5，则二分类的判别式为 y= \begin{cases} 1, & h_\theta(x)\ge0.5 \\ 0, & h_\theta(x)]]></content>
      <categories>
        <category>mechine learning</category>
      </categories>
      <tags>
        <tag>word2vec</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单好用的lambda与Stream]]></title>
    <url>%2F2018%2F09%2F18%2Flambda-introduce%2F</url>
    <content type="text"><![CDATA[lambda表达式是java8的新特性，使java在编程中更简单，代码更简洁可读，避免了冗长的内部类、匿名类，下面通过栗子看看lambda有哪些应用吧*^-^* ForEach 与 lambda12345678910111213Map&lt;String, Integer&gt; items = new HashMap&lt;&gt;();items.put("A", 10);items.put("B", 20);items.put("C", 30);items.put("D", 40);// 原来的写法for (Map.Entry&lt;String, Integer&gt; entry : items.entrySet()) &#123; System.out.println("item : " + entry.getKey() + "count : " + entry.getValue());&#125;// lambdaitems.forEach((k, v)-&gt;&#123; System.out.println("item : " + k + "count : " + v);&#125;); 12345678910111213List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add("A");list.add("B");list.add("C");list.add("D");list.add("E");for(String item : list)&#123; System.out.println(item);&#125;// lambda 参数只有一个可以省略小括号，后面的表达式只有一句可以省略&#123;&#125;,return和分号list.forEach(x-&gt;System.out.println(x));// 上一句的简写list.forEach(System.out::println); 匿名内部类 与 lambda123456789Thread t = new Thread(new Runnable() &#123; public void run() &#123; System.out.println("How a u..."); &#125;&#125;);t.start();// lamdaThread t1 = new Thread(()-&gt;System.out.println("I'm fine...thx"));t1.start(); 12345678910111213141516String[] arr = &#123;"a", "b", "c"&#125;;List&lt;String&gt; list = Arrays.asList(arr);// 匿名内部类Collections.sort(list, new Comparator&lt;String&gt;() &#123; @Override public int compare(String o1, String o2) &#123; return o1.compareTo(o2); &#125; &#125;);// lambdaCollections.sort(list, (s1, s2)-&gt;&#123; return s1.compareTo(s2);&#125;);// 当表达式只有一句时 return 可以省略Collections.sort(list, (s1, s2)-&gt;s1.compareTo(s2)); lambda语法一般语法 ( 参数列表 )-&gt;{ 表达式语句 } (Type parameter, Type parameter,...) -&gt; {statements...} 单参数 parameter-&gt;{statements} 当 lambda 表达式的参数个数只有一个，可以省略小括号 单语句 parameter-&gt;statement 当 lambda 表达式只有一条语句时，可以省略大括号，return 和结尾的分号 方法引用 objectName::instanceMethod 或ClassName::staticMethod 把 lambda 表达式的参数直接当成 instanceMethod 或 staticMethod 的参数，比如System.out::println等同于x-&gt;System.out.println(x)，Math::max等同于(x,y)-&gt;Math::max(x,y) ClassName::instanceMethod是x-&gt;x.instanceMethod()的简化，eg: Student::getName等同于x-&gt;x.getName()，instanceMethod是一个无参的函数 访问外部变量 只能访问外部变量，不能在 lambda 内部修改，编译器将隐式将外部变量当成 final 处理，匿名函数和 lambda 函数内对外部变量的访问是一样的，都是只能访问 final 修饰的，没有 final 修饰视为 final 修饰，不可改变值。 Stream 与 lambda 流式处理Stream 是java8的新特性，大大简化了对集合的操作，本节只看顺序流式处理，请先看看下面的栗子*^-^* 找出集合中的偶数 12345678910List&lt;Integer&gt; nums = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);List&lt;Integer&gt; evens = new ArrayList&lt;&gt;();for (final int n : nums) &#123; if (n % 2 == 0) &#123; evens.add(n); &#125;&#125;// streamevens = nums.stream().filter(num-&gt;num%2 == 0).collect(Collectors.toList());evens.forEach(System.out::println); 上面的例子中，通过 stream() 将集合转成流，filter() 对流进行过滤，筛选后的结果由收集器 collect() 对结果进行封装处理 中间操作 我们先定义一个学生实体类，用来说明中间操作有什么应用 123456789public class Student &#123; private int id; private String name; private int age; private int score; private String school; private String document; //... Getters,Setters,Constructor等省略&#125; 123456789List&lt;Student&gt; students = new ArrayList&lt;Student&gt;() &#123; &#123; add(new Student(2013201319, "zcl", 18, 100, "HEU", "computer")); add(new Student(2013201320, "zjm", 20, 90, "HEU", "computer")); add(new Student(2013201321, "tyf", 19, 95, "HEU", "software")); add(new Student(2013201322, "zzh", 22, 97, "HIT", "computer")); add(new Student(2013201323, "ggy", 21, 89, "HIT", "software")); &#125;&#125;; 过滤filter 过滤姓名以‘z’开头的 12List&lt;Student&gt; z_list = students.stream().filter(stu-&gt;stu.getName() .charAt(0) == 'z').collect(Collectors.toList()); distinct 找出偶数后去掉重复的 12List&lt;Integer&gt; evens = nums.stream().filter(num-&gt;num%2==0) .distinct().collect(Collectors.toList()); sort&amp;limit 找出成绩排名前三的同学 12List&lt;Student&gt; scoreList = this.students.stream().sorted((s1, s2)-&gt; s2.getScore() - s1.getScore()).limit(3).collect(Collectors.toList()); skip 找出成绩排名第三名以后的同学 12List&lt;Student&gt; scoreList = this.students.stream().sorted((s1, s2)-&gt; s2.getScore() - s1.getScore()).skip(3).collect(Collectors.toList()); 映射当我们只想得到一个类的某一个属性值 map 想筛选出所有成绩大于80分的同学的名字，总分和平均分 (mapToInt, mapToDouble) 1234List&lt;String&gt; names = this.students.stream().filter(s-&gt;s.getScore()&gt;80) .map(Student::getName).collect(Collectors.toList());int sum = this.students.stream().mapToInt(Student::getScore).sum();OptionalDouble average_score = this.students.stream().mapToDouble(Student::getScore).average(); flagMap 现在想求几个字符串中出现的字符，比如String[] strs = {&quot;java&quot;, &quot;is&quot;, &quot;easy&quot;, &quot;to&quot;, &quot;use&quot;};，用方法一，先将集合中的每个字符串分解成字符数组，在 distinct 操作是在字符数组之间找的，不是以字符为单位；方法二，flagMap 将一个流中每个值都转成一个个流，然后再将这些流扁平化成为一个流，这样可以达到目的 123456789101112// 方法一Arrays.stream(strs).map(s-&gt;s.split("")) .distinct().collect(Collectors.toList()).forEach(l-&gt;&#123; Arrays.asList(l).forEach(s -&gt; System.out.print(s + " ")); System.out.println(); &#125;);// 方法二Arrays.stream(strs).map(s-&gt;s.split("")) .flatMap(Arrays::stream).distinct().sorted(). collect(Collectors.toList()).forEach(l-&gt;&#123; Arrays.asList(l).forEach(s-&gt; System.out.print(s + " ")); &#125;); 终端操作查找 allMatch：检测是否全部满足指定的参数行为，如果全部满则返回 true，否则返回 false anyMatch：检测是否存在满足条件 noneMatch：是否不存在 findFirst：找第一 findAny：找任意一个（顺序流式处理中，findFirst 和 findAny 返回的结果是一样的） 归约reduce方法 123456789101112// 非reduce写法int totalAge = this.students.stream() .filter(s-&gt;s.getAge()&gt;18) .mapToInt(Student::getAge).sum();// 规约操作int totalAge1 = this.students.stream().filter(s-&gt;s.getAge()&gt;18) .mapToInt(Student::getAge).reduce(0, (a, b)-&gt;a + b);int totalAge2 = this.students.stream().filter(s-&gt;s.getAge()&gt;18) .map(Student::getAge).reduce(0, Integer::sum);Optional&lt;Integer&gt; totalAge3 = this.students.stream() .filter(s-&gt;s.getAge()&gt;18) .map(Student::getAge).reduce(Integer::sum); 收集 经过中间操作处理后结果的封装，比如collect(Collectors.toList())，类似的还有 toSet``toMap，这些方法都来自于 java.util.stream.Collectors这个收集器 下面的栗子是相同功能的不同写法（“回”字的不同写法） 12345678910111213141516171819202122// 及格学生总数long a = this.students.stream().filter(s-&gt;s.getScore()&gt;60).collect(Collectors.counting());long b = this.students.stream().filter(s-&gt;s.getScore()&gt;60).count();// 最高分，最低分Optional&lt;Student&gt; maxScore = this.students.stream() .collect(Collectors.maxBy((s1, s2)-&gt;s1.getScore()-s2.getScore()));Optional&lt;Student&gt; maxScore = this.students.stream() .collect(Collectors.maxBy(Comparator.comparing(Student::getScore)));Optional&lt;Student&gt; maxScore = this.students.stream() .collect(Collectors.minBy(Comparator.comparing(Student::getScore)));// 总分和平均分int totalScore = this.students.stream().collect(Collectors.summingInt(Student::getScore));double averageScore = this.students.stream() .collect(Collectors.averagingInt(Student::getScore));// 一次性统计得到元素个数、总和、均值、最大值、最小值（这封装的也是够了）IntSummaryStatistics statistics = this.students.stream() .collect(Collectors.summarizingInt(Student::getScore));// 字符串拼接String names = this.students.stream().map(Student::getName) .collect(Collectors.joining());String names1 = this.students.stream().map(Student::getName) .collect(Collectors.joining(", ")); // 用", "分隔名字 分组1234567// 按学校对集合分组Map&lt;String, List&lt;Student&gt;&gt; groups = this.students.stream().collect(Collectors.groupingBy(Student::getSchool));groups.forEach((k, v)-&gt;&#123; System.out.println(k); v.forEach(x-&gt;System.out.print(x.getName() + " ")); System.out.println();&#125;); groupingBy 接收一个分类器Function&lt;? super T, ? extends K&gt; classifier，可以一级或多级分类，如： 123Map&lt;String, Map&lt;String, List&lt;Student&gt;&gt;&gt; group = this.students.stream().collect( Collectors.groupingBy(Student::getSchool, Collectors.groupingBy(Student::getDocument))); groupingBy 的第二个参数可以传递任意 Collector 类型，如 Collectors.groupingBy，Collectors.counting，如果不添加第二个参数，默认是Collectors.toList 123// 集合中一个学校的人数，按学校分组后统计组内人数Map&lt;String, Long&gt; groups = this.students.stream().collect( Collectors.groupingBy(Student::getSchool, Collectors.counting())); 区分 区分是分组的一种特殊情况，将集合内容分为 true, flase 两类，比如求男女人数；下面是区分的两种写法，用 groupingBy 和 partitioningBy 都能实现 12345// 求集合中学生是HEU 和不是 HEU 的人数（列表）Map&lt;Boolean, Long&gt; groups = this.students.stream().collect( Collectors.groupingBy(x-&gt;x.getSchool().equals("HEU"), Collectors.counting()));Map&lt;Boolean, List&lt;Student&gt;&gt; partition = this.students.stream().collect( Collectors.partitioningBy(stu-&gt;"HEU".equals(stu.getSchool()))); 并行流式数据处理 充分利用计算机的CPU内核数，并发处理的思想。将 stream() 替换成 parallelStream()即可，但会涉及多线程安全问题，当然效率提高的很多。 参考文献java8 新特性 lamda和Stream Java8 新特性之流式数据处理]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm gc]]></title>
    <url>%2F2018%2F08%2F20%2Fjvm-gc%2F</url>
    <content type="text"><![CDATA[JavaGC (Garbage Collection, 垃圾收集) 机制，下面介绍的是 HotSpot 的 GC 机制。Java GC 机制可以自动的回收内存，保证 JVM 中的内存空间充足，防止内存泄漏溢出。对于一般的程序，Java GC 可以自动的完成绝大多数事情，然而，对于较大型的应用软件，需要对 JVM 进行优化，必须要清楚 Java GC 机制。 java GC 要干啥 确定哪些内存要回收 何时执行 GC 怎样执行 GC JVM 内存区域的划分 程序计数器 (Program Counter Register) 虚拟机栈 (JVM Stack) 本地方法栈 (Native Method Statck) 堆区 (Heap) 方法区 (Method Area) 直接内存 (Direct Memory) java 对象的内存访问哪些内存需要回收何时触发 GC 和执行 GC 的方式]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[singleton]]></title>
    <url>%2F2018%2F08%2F18%2Fsingleton%2F</url>
    <content type="text"><![CDATA[多线程安全的单例模式某类只能有一个对象，构造函数为 private，通过静态成员变量和函数获得变量 模式1 类加载的时候直接 new 出静态对象，无法懒加载，降低内存的使用率 12345678910public class Singleton &#123; // 直接初始化一个实例对象 private static Singleton instance = new Singleton(); // 私有构造方法保证其他类对象不能直接 new 该对象的实例 private Singleton() &#123;&#125; public static Singleton getInstance() &#123; return instance; &#125;&#125; 模式2 多线程创建实例，一个时刻只能有一个线程得到同步锁，但是，每次通过 getInstance 方法得到 singleton 实例都要获得锁，但是只有第一次创建锁才有意义，加锁是很耗时的操作 12345678910public class Singleton &#123; private static Singleton instance = null; private Singleton() &#123;&#125; public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 模式3 只有当 instance 为 null 时，才需要加锁，也只需创建一次实例，以后则无需加锁 123456789101112131415public class Singleton &#123; private static Singleton instance = null; private Singleton() &#123;&#125; public static Singleton getInstance() &#123; // 先判断实例是否初始化 if (instance == null) &#123; synchronized(Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 模式4 私有内部类；不用加锁，也能实现懒加载，最好的了吧 123456789public class Singleton &#123; private Singleton() &#123;&#125; private static class Inner &#123; private static Singleton s = new Singleton(); &#125; public static Singleton getSingle() &#123; return Inner.s; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[elastic search]]></title>
    <url>%2F2018%2F08%2F09%2Felastic-search%2F</url>
    <content type="text"><![CDATA[文档搜索query string search GET (index/type)/_search(?parameter_name=parameter_value&amp;...) () 内为可选项，如无条件查询: GET /_search GET /_search?q=name:zjm&amp;sort=no:desc 当搜索条件复杂时构建 query string 很麻烦，生产环境很少使用 query DSL DSL: Domain Specified Language 12345678910111213141516171819202122232425262728293031323334353637383940# 查询所有数据GET /index/type/_search &#123; "query": &#123;"match_all":&#123;&#125;&#125;&#125;# 条件查询，排序GET /index1/type1/_search&#123; "query": &#123; "match": &#123; "name": "zjm" &#125; &#125;, "sort": [ &#123; "age": &#123; "order": "desc" &#125; &#125; ]&#125;# 分页GET /_search&#123; "query": &#123;"match_all": &#123;&#125;&#125;, "from": 1, # 从第几条开始 "size": 2, # 查询的数据个数 "sort": [ &#123;"age": "desc"&#125; ]&#125;# 查询部分字段GET _search&#123; "query": &#123;"match_all": &#123;&#125;&#125;, "_source": ["name", "age"], "sort": [ &#123;"age": "asc"&#125; ]&#125; query filter 过滤查询，是 query DSL 的补充，不进行匹配相关度计算 eg: 搜索 position 包含 java 且年龄在 22-24 之间 1234567891011121314151617181920212223242526272829303132333435363738394041GET /index1/type1/_search&#123; "query": &#123; "bool": &#123; # 多条件搜索 "must": [ &#123;"match": &#123; "position": "java" &#125;&#125;, &#123; "range": &#123; "age": &#123; "gte": 22, "lte": 24 &#125; &#125; &#125; ] &#125; &#125;&#125;# 使用 FilterGET /index1/type1/_search&#123; "query": &#123; "bool": &#123; "must": [ &#123;"match": &#123; "position": "java" &#125;&#125; ], "filter": &#123; "range": &#123; "age": &#123; "gte": 22, "lte": 24 &#125; &#125; &#125; &#125; &#125;&#125; 注：filter 在 must 的结果中进行过滤，filter中的字段不进行相关度计算 full-text search 全文匹配：position 中含有 java 或 php 或 scale的，词与词之间属于独立的条件 12345678GET /index1/type1/_search&#123; "query": &#123; "match": &#123; "position": "java php scale" &#125; &#125;&#125; phrase search 短语检索：position 含有 java developer 这个短语，只有 java 或者 developer 不行的呦 12345678GET /index1/type1/_search&#123; "query": &#123; "match_phrase": &#123; "position": "java developer" &#125; &#125;&#125; highlight display 高亮显示 123456789101112131415GET /index1/type1/_search&#123; "query": &#123; "match": &#123; "name": "zjm" &#125; &#125;, "highlight": &#123; "fields":[ &#123; "name" : &#123;&#125; &#125; ] &#125;&#125;]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elasticSearch</tag>
        <tag>kibana</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[producter&consumer]]></title>
    <url>%2F2018%2F07%2F18%2Fproducter-consumer%2F</url>
    <content type="text"><![CDATA[生产者消费者wait &amp; notifyAll 使用 wait, notifyAll 实现生产者消费者问题，注意使用 while 判断容器的容量和 notifyAll 通知所有等待线程，notify只会唤醒一个线程，比如生产者将容器放满，又唤醒了一个生产者，使唤醒的生产者进入死循环，无法唤醒其他线程 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.util.LinkedList;import java.util.concurrent.TimeUnit;public class MyContainer1&lt;T&gt; &#123; final private LinkedList&lt;T&gt; lists = new LinkedList&lt;&gt;(); final private int MAX = 10; // 生产者放入 public synchronized void put(T t) &#123; while (lists.size() == MAX) &#123; try &#123; this.wait(); // wait 一般外面都是 while，如果用if，且生产者唤醒生产者，会继续向下执行向容器中添加，导致超出最大容量 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; lists.add(t); this.notifyAll();// 不能用notify!!! 通知所有等待线程，希望唤醒的是消费者 &#125; // 消费者取出 public synchronized T get() &#123; T t = null; while (lists.size() == 0) &#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; t = lists.removeFirst(); this.notifyAll();// 通知生产者线程进行生产 return t; &#125; public static void main(String[] args) &#123; MyContainer1&lt;String&gt; c = new MyContainer1&lt;&gt;(); // 启动消费者线程 for (int i=0; i&lt;10; i++) &#123; new Thread(()-&gt;&#123; for (int j=0; j&lt;5; j++) &#123; System.out.println(c.get()); &#125; &#125;, "c" + i).start(); &#125; try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 启动生产者线程 for (int i=0; i&lt;2; i++) &#123; new Thread(()-&gt;&#123; for (int j=0; j&lt;25; j++) &#123; c.put(Thread.currentThread().getName() + " " + j); &#125; &#125;, "p" + i).start(); &#125; &#125;&#125; ReentrantLock &amp; Condition 使用 ReentrantLock 和 Condition 实现P-C问题，能够控制哪些线程等待与唤醒，对于同一个锁，创建多个Condition 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import java.util.LinkedList;import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class MyContainer2&lt;T&gt; &#123; final private LinkedList&lt;T&gt; lists = new LinkedList&lt;&gt;(); final private int MAX = 10; private Lock lock = new ReentrantLock(); private Condition producer = lock.newCondition(); private Condition consumer = lock.newCondition(); // 生产者 public void put(T t) &#123; try &#123; lock.lock(); while (lists.size() == MAX) &#123; producer.await();// 满了生产者等待 &#125; lists.add(t); consumer.signalAll();// 唤醒消费者来取 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; // 消费者 public T get() &#123; T t = null; try &#123; lock.lock(); while (lists.isEmpty()) &#123; consumer.await();// 没有可以取的 &#125; t = lists.removeFirst(); // 有则取走 producer.signalAll();// 通知生产者放 &#125; catch(InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; return t; &#125; public static void main(String[] args) &#123; MyContainer2&lt;String&gt; c = new MyContainer2&lt;&gt;(); // 消费者线程 10*5，要小于生产者放入的个数 for (int i=0; i&lt;10; i++) &#123; new Thread(()-&gt;&#123; for (int j=0; j&lt;5; j++) &#123; System.out.println(c.get()); &#125; &#125;, "c" + i).start(); &#125; try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 生产者线程 2*25 要大于消费者取出的个数，如果小于消费者取出的个数，消费者会因取不到而死循环 for (int i=0; i&lt;2; i++) &#123; new Thread(()-&gt;&#123; for (int j=0; j&lt;25; j++) &#123; c.put(Thread.currentThread().getName() + " " + j); &#125; &#125;, "p" + i).start(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[concurrent]]></title>
    <url>%2F2018%2F07%2F14%2Fconcurrent%2F</url>
    <content type="text"><![CDATA[java 并发处理为什么要加锁 下面的例子，自增操作不具备原子性，导致多个线程同时对 count 操作时相互影响，比如一次操作一个线程取到的 count 为100，当它完成 ++ 操作把 count 赋值为 101 的时候，可能覆盖掉了这期间别的线程对count 的操作，最后结果远小于100000 12345678910111213141516171819202122232425262728293031import java.util.ArrayList;import java.util.List;public class T implements Runnable &#123; private int count = 0; // 加上 synchronized 后，线程依次执行run方法，不会相互影响 public /*synchronized*/ void run() &#123; for (int i=0;i&lt;10000;i++) &#123; count ++; &#125; &#125; public static void main(String[] args) &#123; T t = new T(); List&lt;Thread&gt; tl = new ArrayList&lt;&gt;(); for(int i=0; i&lt;5; i++) &#123; tl.add(new Thread(t, "THREAD" + i)); &#125; tl.forEach((o)-&gt;o.start()); // 等待所有线程结束 tl.forEach((o)-&gt;&#123; try &#123; o.join(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;); System.out.println(t.count); &#125;&#125; synchronized 锁定堆内存中的对象，线程执行过程中一定要取到对象的🔒才能执行，否则等待当前线程释放对象的🔒并获取才能执行，语法： 123456789101112131415161718public class Concurrent &#123; public void m() &#123; synchronized (this) &#123; // 要并发处理的代码 &#125; &#125; // or 同步方法：函数内的所有代码都加锁 public synchronized void m() &#123; &#125; // 一下两种写法都是在静态函数中锁定对象的类 public static void m() &#123; synchronized(T.class) &#125; public synchronized static void m() &#123; &#125;&#125; 注： synchronized 修饰的代码越少越好，不要包含无需并发处理的代码 锁定的是堆中的对象，不是栈中的引用，应该避免将锁定对象的引用变成另外的对象 不要以字符串常量做锁定对象：String a=&quot;hello&quot;; String b=&quot;hello&quot;; a 和 b 指向的同一个对象 对写方法加锁，读方法不加锁，容易产生脏读 (dirtyRead)（在没写完就读，读到的是过时的值） synchronized 获得的锁是可重入的：在一个类的同步方法 a() 调用该类（父类）中的另一个同步方法 b()，在这个线程已经拥有了对象的锁时候，再次申请的时候任然会得到该对象的锁。 线程执行过程中如果发生异常，默认情况锁会被释放 volatile volatile 关键字使一个变量在多个线程间可见 原理：A线程用到一个变量时，java 会在线程中保留一份copy，这样如果 B线程修改了该变量，则 A线程未必知道，使用 volatile 关键字可以让所有线程再去内存里读一下更新变量的值。 volatile boolean running = true; volatile 不能保证多线程同时对一个变量修改带来的不一致问题，不能替代 synchronized，即只能保证可见性，不能保证原子性 例如： 123456789101112131415161718192021public class T &#123; volatile int count = 0; void m() &#123; for(int i=0; i&lt;10000; i++) count++; &#125; public static void main(String[] args) &#123; T t = new T(); List&lt;Thread&gt; threads = new ArrayList&lt;Thread&gt;(); for(int i=0; i&lt;10; i++) &#123; threads.add(new Thread(t::m, "thread-"+i)); &#125; threads.forEach((o)-&gt;o.start()); threads.forEach((o)-&gt;&#123; try &#123; o.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); System.out.println(t.count); &#125; 上面的例子输出的结果小于100000，因为多线程同时修改变量的值，即使随时都去内存里相互更新，但互相影响，解决办法是让 m() 前加上 synchronized 修饰。 123456/*volatile*/ int count = 0;synchronized void m() &#123; for (int i = 0; i &lt; 10000; i++) count++; &#125; 但 synchronized 效率不高，有没有更好的方法呢… AtomicXXX AtomicXXX 类的方法都是原子性的，但是多个方法之间是不具备原子性的 AtomicXXX 效率很高，推荐使用 12345678910111213141516171819202122232425public class T &#123; // volatile int count = 0; AtomicInteger count = new AtomicInteger(0); void m() &#123; for (int i = 0; i &lt; 10000; i++) // while (count.get() &lt; 10000) 对于count 的 get 和 incrementAndGet() 之间不具有原子性，导致get的时候小于10000，但因为多线程共同increment可能使得最后结果大于100000 count.incrementAndGet(); &#125; public static void main(String[] args) &#123; T t = new T(); List&lt;Thread&gt; threads = new ArrayList&lt;Thread&gt;(); for (int i = 0; i &lt; 10; i++) &#123; threads.add(new Thread(t::m, "thread-" + i)); &#125; threads.forEach((o) -&gt; o.start()); threads.forEach((o) -&gt; &#123; try &#123; o.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); System.out.println(t.count); &#125;&#125; 线程间通信Wait &amp; Notify 小故事：厕所里只有一个坑，有很多人冲了进来上厕所，只有一个人占有了这个坑并锁上了门，其他人只能等待，处于就绪状态。就绪状态的线程是处于可运行线程池中的，就绪状态的线程除CPU之外，其他运行所需资源都已全部获得；那么厕所就是这个可运行线程池，等待的人就是就绪线程，一旦门开了，即有一个就绪线程可以运行；这把锁就相当于synchronized 锁住了坑这个对象，就绪状态的人持有资源但不能运行，无形中是一种浪费。那么，可不可以让他们先别持有资源了，先离开厕所回到座位去 wait（阻塞状态），等里面的人出来了再冲进去争抢呢？阻塞状态的线程释放占有的所有资源进入等待池中，这个状态是不能自己唤醒的，需要有人通知（notify）才被唤醒，节省了资源。 wait 会释放锁，线程进入阻塞态，前提是先获得锁，一般与 synchronized 配合使用，外面一般是 while notify 不会释放锁，会唤醒 wait 的线程，不会立即释放锁；notify 只会唤醒一个等待（对象的）线程，notifyAll 会唤醒所有等待（对象的）线程，《Effective Java》中说永远使用 notifyAll 不要使用 notify。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import java.util.concurrent.TimeUnit;public class T &#123; boolean volatile session = false; String volatile content = ""; public static void main(String[] args) &#123; T t = new T(); final Object lock = new Object(); new Thread(()-&gt;&#123; System.out.println("t1 start"); synchronized(lock) &#123; while (!t.session) &#123; try &#123; lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(t.content); System.out.println("t2 end"); lock.notifyAll(); // 唤醒 t2 &#125; &#125;, "t1").start(); try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; new Thread(()-&gt;&#123; System.out.println("t2 start"); synchronized (lock) &#123; for (int i=1; i&lt;=10; i++) &#123; System.out.println(i); if (i == 5) &#123; t.session = true; lock.notifyAll(); // 唤醒 t1 t.content = "Hello " + i; try &#123; lock.wait(); // 释放锁 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;, "t2").start(); &#125;&#125; Latch wait 和 notify 通信过程比较繁琐，使用 Latch 代替 wait, notify来进行线程间的通知，好处是使通讯简单，可以指定等待时间 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.concurrent.CountDownLatch;import java.util.concurrent.TimeUnit;public class T3 &#123; private volatile int num = 0; public static void main(String[] args) &#123; T3 t = new T3(); CountDownLatch latch = new CountDownLatch(1); // latch的count值为1，下面自减为0可唤醒所有等待线程 new Thread(()-&gt;&#123; System.out.println("t1 start"); if (t.num != 5) &#123; try &#123; latch.await(); // 等待，放弃锁 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; System.out.println("t1 end"); &#125;, "t1").start(); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; new Thread(()-&gt;&#123; System.out.println("t2 start"); for (int i=0; i&lt;10; i++) &#123; System.out.println("t2:" + i); if (i == 5) &#123; latch.countDown(); // latch的count由1变0，唤醒t1 &#125; try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; System.out.println("t2 end"); &#125;, "t2").start(); &#125;&#125; ReentrantLock ReentrantLock 可以替代 synchronized 锁定 this 对象，锁定后必须要手动释放锁，经常在 finally 中进行锁的释放，synchronized 释放锁后随机选择等待的线程开始执行，ReentrantLock 可以指定为公平锁。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class T &#123; Lock lock = new ReentrantLock(); void m1() &#123; lock.lock(); // 加锁 try &#123; for (int i=0; i&lt;10; i++) &#123; System.out.println(i); TimeUnit.SECONDS.sleep(1); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); // 手动释放锁 &#125; &#125; // 同 synchronized void m2() &#123;&#125; void m2() &#123; lock.lock(); System.out.println("m2 start..."); lock.unlock(); &#125; void m3() &#123; boolean isLocked = false; try &#123; isLocked = lock.tryLock(5, TimeUnit.SECONDS); // 尝试5s获得锁，获得不到返回false，继续向下执行 System.out.println("m2 start..."); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; if (isLocked) lock.unlock(); &#125; &#125; public static void main(String[] args) &#123; T t = new T(); new Thread(t::m1).start(); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; new Thread(t::m2).start(); &#125;&#125; 当线程 t2 等待线程 t1，而线程t1长时间占用 cpu，可以手动让 t2 打断 t1，令 t2 执行。 12345678910111213141516171819202122232425262728Thread t1 = new Thread(()-&gt;&#123; try &#123; lock.lock(); TimeUnit.SECONDS.sleep(Integer.MAX_VALUE); &#125; catch(InterruptedException e) &#123; System.out.println("interrupted!"); &#125; finally &#123; lock.unlock(); &#125;&#125;);t1.start();// 睡2sThread t2 = new Thread(()-&gt;&#123; boolean locked = lock.tryLock(); try &#123; lock.lockInterruptibly(); System.out.println(Thread.currentThread().getName() + " start"); TimeUnit.SECONDS.sleep(5); &#125; catch(InterruptedException e) &#123; System.out.println("t2 interrupted"); &#125; finally &#123; if (locked) lock.unlock(); &#125; System.out.println(Thread.currentThread().getName() + " end");&#125;, "t2");t2.start();// 睡2st2.interrupt(); 公平锁：唤醒等待线程按照先来先服务的机制而不是随机，当然公平会带来一定的负担 12345678910111213141516171819202122import java.util.concurrent.locks.ReentrantLock;public class T4 implements Runnable&#123; private static ReentrantLock lock = new ReentrantLock(true); //参数为true表示为公平锁 public static void main(String[] args) &#123; T4 t = new T4(); Thread t1 = new Thread(t); Thread t2 = new Thread(t); t1.start(); t2.start(); &#125; @Override public void run() &#123; for (int i=0; i&lt;100; i++) &#123; lock.lock(); System.out.println(Thread.currentThread().getName() + "获得锁"); lock.unlock(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[elasticSearch kibana install in linux]]></title>
    <url>%2F2018%2F05%2F06%2Felasticsearch-kibana-install%2F</url>
    <content type="text"><![CDATA[Linux 安装 ES ES 6.3.x 要求 Linux 内核必须是 3.5+版本以上，不能用 root 用户启动 uname -a 查看 linux 内核版本，低于3.5要升级内核，或者使用Centos7 升级内核 注册内核： rpm –import http://mirror.centos.org/centos/RPM-GPG-KEY-CentOS-7 下载内核安装包 rpm -Uvh http://www.elrepo.org/elrepo-release-6-8.el6.elrepo.noarch.rpm 安装内核新版本 yum --enablerepo=elrepo-kernel install kernel-lt -y 设置启动内核版本 vim /etc/grub.conf 修改为：default=0 重启系统让内核生效：reboot（还是直接用 Centos7 吧乖乖） 注意： 高版本的内核对线程的内存资源需要更高的要求，要给虚拟机分配 1.5G 以上的内存 配置虚拟机网关，DNS，保证能连接外网 为ES提供系统配置 ES 在 Linux 安装部署需要系统为其提供若干系统配置，如：应用可启动的线程数，可以划分到的内存，最多可以创建的文件… 修改限制信息 修改系统中允许应用创建最多文件个数的限制权限。Linux 默认限制应用最多创建 65535 个文件，但是 ES 至少需要65536 个文件的创建权限。 1234vi /etc/security/limits.conf# 增加* soft nofile 65536* hard nofile 65536 修改线程开启限制 修改允许用户启动的进程开启多少线程，Linux 限制 root 用户开启的进程可以启动任意数量的线程，其他用户开启的进程可以开启 1024 个线程。修改限制数为 4096+。ES 至少需要4096的线程池预备 123456vi /etc/security/limits.d/90-nproc.conf# 修改下述内容* soft nproc 4096root soft nproc unlimited# 检查可开启的最大线程ulimit -u 注：虚拟机内存是 1 G，最多能开启3000+个线程，不能满足ES的要求，所以要给虚拟机分配1.5G以上的内存 修改系统控制权限 系统控制文件是管理系统中资源控制的配置文件，ES需要开辟一个65536字节以上空间的虚拟内存。Linux默认不允许任何用户和应用直接开辟虚拟内存 12345vi /etc/sysctl.conf# 添加vm.max_map_count=655360# 让 sysctl 配置生效sysctl -p 安装JDK至少1.8.0_131+ 解压ES：tar -zxf elasticsearch-6.3.1.tar.gz 注：ES 不允许 root 用户启动，如果 ES 是通过 root 用户解压的，则所有者是 root 用户，需要将ES 应用所有者改为其他用户 修改所有者 123# 先移动到普通用户路径下： mv #path1 path2chown -R group.user elasticsearch... # 无组用户的组名和用户名一致 修改elasticsearch配置文件 设置可访问的客户端。0.0.0.0代表任意客户端访问。 123vi config/elasticsearch.yml# 修改下述内容network.host: 0.0.0.0 切换用户启动：su zjm，cd elasticsearch/bin，./elasticsearch 启动服务 测试连接：curl http://ip:9200 Linux安装Kibana是ES提供的一个Web的管理控制台，解压，启动即可，Kibana要求的环境配置是小于ES的 tar -zxf kibana.tar.gz 修改 config/kibana.yml，增加：server.host: “0.0.0.0” 运行：kibana_home/bin/kabana‘ 访问：http://ip:5601]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elasticSearch</tag>
        <tag>kibana</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kibana command]]></title>
    <url>%2F2018%2F04%2F08%2Fkibana-command%2F</url>
    <content type="text"><![CDATA[Kibana 命令查看Kibana启动结果 浏览器访问：http://ip:5601 进入 dev tools 模块，执行GET _cluster/health 返回值中 status: green：每个索引的 primary shard 和 replica shard 都是 active 的 yellow：每个索引的 primary shard 都是 active 的，但部分的 replica shard 不是 active 的 red：不是所有的索引都是 primary shard 都是 active 状态的 查看健康状态 GET _cat/health?v 索引创建索引1234567put /test_index&#123; "settings":&#123; "number_of_shards" : 2, "number_of_replicas" : 1 &#125;&#125; ES 默认创建索引会分配 5 个 primary shard，并为每个 primary shard 分配一个 replica shard。限制：如果磁盘空间不足 15% 时不分配 replica shard，不足 5% 时不分配 primary shard 可以设置 primary shard 的个数和每个 primary shard 的 replica shard 的个数 修改索引 索引一旦创建，primary shard 数量不可变化，可以改变replica shard 的数量： 1234PUT /test_index/_settings&#123; "number_of_replicas": 2&#125; 一个主分片和他的备份分片不会在一个节点上，对于一个主分片的多个备份分片也不会在一个节点上（很好理解——防止同时消失） 删除索引 DELETE /test_index,...，逗号分隔索引 查看索引 GET _cat/indices?v 查看分片 GET _cat/shards?v 123456789101112# 索引名 # 编号 # 主从 # 所在节点index shard prirep state docs store ip nodetest_index 3 r STARTED 0 261b 127.0.0.1 uwrhdxHtest_index 3 p STARTED 0 261b 127.0.0.1 9kTJ5Qetest_index 1 r STARTED 0 261b 127.0.0.1 uwrhdxHtest_index 1 p STARTED 0 261b 127.0.0.1 9kTJ5Qetest_index 2 p STARTED 0 261b 127.0.0.1 uwrhdxHtest_index 2 r STARTED 0 261b 127.0.0.1 9kTJ5Qetest_index 4 p STARTED 0 261b 127.0.0.1 uwrhdxHtest_index 4 r STARTED 0 261b 127.0.0.1 9kTJ5Qetest_index 0 p STARTED 0 261b 127.0.0.1 uwrhdxHtest_index 0 r STARTED 0 261b 127.0.0.1 9kTJ5Qe 可以发现 test_index 索引有 5 个主分片，每个主分片都有一个备份分片，并且主从分片不在一个节点上，5 个 primary shard 必须全部活动才能正常使用，否则集群 state = red 注：ES 索引一旦建立，不可改变，即 primary shard 不变 文档新增 Document 在索引中增加文档，如果增加的 document 对应的 index 不存在，自动创建，如果 index 存在， type 不存在也自动创建。 手动指定 id 的 Document 12345678910111213141516171819202122# Put /index/type/id &#123;field: value&#125;PUT /test_index/type1/1&#123; "name": "zjm", "remark": "IT boy", "no": 1&#125;# result:&#123; "_index": "test_index", # document 的索引 "_type": "type1", "_id": "1", "_version": 1, "result": "created", "_shards": &#123; "total": 2, # primary shard number "successful": 2, "failed": 0 &#125;, "_seq_no": 1, "_primary_term": 1&#125; 自动生成 id 1234567# POST /index/type&#123;field: value&#125;POST /test_index/my_type&#123; "name": "shaunjm", "remark": "my blog", "no": 2&#125; 注：每个 index 里的 document 结构差异不要太大！ 查询 Document GET 查询（单数据）：GET /index/type/id GET /_mget 批量查询（效率高，比单数据查询，推荐） 12345678910111213141516171819GET /_mget&#123; "docs": [ &#123; "_index": "...", "_type": "...", "_id": "..." &#125;, &#123;&#125;, &#123;&#125; ]&#125;# orGET /index/type/_mget&#123; "docs": [ &#123; "_id": "..." &#125;, &#123;&#125;, &#123;&#125; ]&#125; 替换 Document 替换 Document (全量替换) 语法同新增完全一样：PUT /index/type/id {field:value}，ES会先把原来 id 的文档标记为deleted，再新建，如果不存在 id 的数据则新增 PUT 的强制新增PUT /index/type/id/_create {} 或 PUT /index/type/id?op_type=create {}如果 id 已经存在则报错 更新 Document POST /index/type/id {&quot;doc&quot;:{field: value}} 只更新 id 文档的部分字段，先将原文档标记为 deleted，再将新字段和未更新的字段合并组成新的文档并创建。 删除 Document DELETE /index/type/id，标记文档为 deleted，不会直接物理删除，当 ES 存储空间不足时才会进行物理删除，状态标记为 deleted 的文档不会被查询搜索到 bulk 批处理增删改 Document12345678POST /_bulk&#123;"create": &#123;"_index": "index1", "_type": "type1", "_id": "1"&#125;&#125;&#123;"name": "zjm", "age": 10&#125;&#123;"index": &#123;"_index": "index1", "_type": "type1", "_id": "1"&#125;&#125;&#123;"name": "zjm22333", "age": 15&#125;&#123;"update": &#123;"_index": "index1", "_type": "type1", "_id": "1", "_retry_on_conflict": 3&#125;&#125;&#123;"doc": &#123;"age": 18&#125;&#125;&#123;"delete": &#123;"_index": "index1", "_type": "type1", "_id": "1"&#125;&#125; 2-3 行为强制新增，4-5 行为新增或全部替换，6-7 行为部分更新，8行为删除，一个文档的 json 中不能含有换行，不同的 json 串必须换行，这是为了字符串直接使用换行进行分隔，每一行为一个 json 对象，否则以 { 和 } 做分隔需要创建字符串数组，影响效率 Document Routing ES 将文档存放在 index 的哪个 primary shard 的路由机制： primary shard = hash(routing)%numbe_of_primary_shards 其中，routing 默认为 Document 的 id，也可以手动指定： PUT /index/type/id?routing=... 这样查询的时候也要带着 routing 值才能查询到，否则会按默认的 routing 值，即 id 进行计算 写操作：计算 routing 后决定写到哪个 primary shard 上， Primary shard 会自动同步对应的 replica shard；读操作：计算 routing 后决定读哪个 primary shard 或者对应的 replica shard，一个 primary shard 对应的 replica shard 越多，可选择的节点越多，并发性就越好 Document 读写流程 读：客户端发送的请求会随机的发送到一个节点上，称为协调节点（coordinate node），协调节点通过路由算法找到本次操作的 Document 所在的 shard，将请求转发 primary shard 或者对应的 replica shard（轮回策略或负载均衡），primary 或 replica shard 返回协调节点，协调节点再将相应返回给客户端 写：同样是随机发送请求到协调节点，协调节点计算出 Document 所在的 shard 后，转发到 shard 所在节点，primary shard 处理完请求后会同步对应的 replica shard，同步数据完成，返回结果到协调节点再到客户端]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>kibana</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-data-process]]></title>
    <url>%2F2018%2F02%2F26%2Fpython-data-process%2F</url>
    <content type="text"><![CDATA[前言 Python 科学计算中用到的数据处理，图像绘制的方法记录。好多不知道啥意思，先背住吧，用到的时候再找…Python 做科学计算东西挺多的，现在还不能自己掌握，得不断积累 随机生成正态分布的数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748__author__ = 'ZJM'__time__ = '2018/2/26 15:22'import numpy as npfrom numpy.linalg import choleskyimport matplotlib.pyplot as pltimport matplotlib.mlab as mlabfrom scipy.stats import multivariate_normalfrom sklearn.mixture import GaussianMixturefrom mpl_toolkits.mplot3d import Axes3DsampleNo = 1000# 一维正太分布mu = 3sigma = 15np.random.seed(0)s = np.random.normal(mu, sigma, sampleNo)plt.subplot(221)n, bins, patches = plt.hist(s, 50, normed=1)# add a best fit lineline = mlab.normpdf(bins, mu, sigma)plt.plot(bins, line, 'r--')plt.xlabel('x')plt.ylabel('y')plt.title(r'$\mu=' + str(mu) + '$, $\sigma=' + str(sigma) + '$')# 二维正态分布mu = np.array([1, 5])sigma = np.array([[1, 0], [0, 1.5]])R = cholesky(sigma)s = np.dot(np.random.randn(sampleNo, 2), R) + muplt.subplot(222)plt.plot(s[:, 0], s[:, 1], '+')# 三维正太分布mu = np.array([0] * 3)# sigma = np.array([[1, 1, 3], [1, 2, 1], [0, 0, 1]])sigma = np.diag((1, 1, 1))data = np.random.multivariate_normal(mu, sigma, 500)norm = multivariate_normal(mu, sigma)tau = norm.pdf(data)fig = plt.figure(figsize=(13, 7), facecolor='w')ax = fig.add_subplot(223, projection='3d')ax.scatter(data[:, 0], data[:, 1], data[:, 2], c='b', s=30, marker='o', depthshade=True)ax.set_xlabel('X')ax.set_ylabel('Y')plt.tight_layout()plt.show()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Scientific Computation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[math basic]]></title>
    <url>%2F2018%2F02%2F24%2Fmath-basic%2F</url>
    <content type="text"><![CDATA[前言 数学功底太差，概率论与数理统计、线性代数，大量概念理解不够，之前的强化记忆都为了应付考试，记题型、背步骤，现在用到数据处理和公式推导时发现都不会了。下面把一些用到的概念记录下，主要是看到的通俗的解释，直观形象的描述。尽量使概念活起来。^ - ^ 线代最小二乘法正交阵 n阶矩阵A，满足ATA=E，则A为正交阵 A=(a1,a2,…,an), A为正交阵，有： aiTai=1, aiTaj=0(i≠j) 即A的行(列)向量都是单位向量，且两两正交 单位向量保证ATA 对角线都是1，正交使得其他元素都是0 A, B 都是n阶正交阵，则A×B是正交阵 对称阵 协方差矩阵，二次型矩阵，无向图邻接矩阵都是对称阵 实对称阵不同特征值的特征向量正交 设A为n阶对称阵，则必有正交阵P，使得P-1AP = PTAP = Λ 其中P为A的特征向量组成的矩阵，Λ对角线上是A的特征值，即A为对称阵，做合同变换，特征值不变，A与Λ互为合同矩阵 正定阵 直观上：正定阵是一种实对称阵 对于n阶方阵A，若任意n阶非零向量x，都有xTAx&gt;0，则称A是正定阵。 给定任意m×n的矩阵A，ATA一定是半正定对称方阵 对称阵A是正定阵，A特征值都为正，A的顺序主子式都为正 向量的导数 问题：A为m×n的矩阵，x为n×1的列向量，则Ax为m×1的列向量，记y=Ax，y对x的偏导为AT 概率期望 平均数的扩展 小学的时候，考语数外，三科一样重要，期末成绩三科求和除以3即可得到平均分。大学了，每科都有学分，学分大的更重要，在所有科目中占的比重就大。求平均分时就要带着权重啦。xk 的概率pk 就相当于它的权重。期望反应数据的平均水平。 离散型： 连续型： 方差 衡量随机变量或一组数据时离散程度 在统计描述中： 在概率分布中： 离散型： ​ 展开后： 连续型： 协方差Cov 描述两个变量在变化过程中同向还是反向，及其程度。 你大我也大，同向，协方差为正 你大我小，反向，协方差为负 协方差数值绝对值越大则程度越强 相关系数ρ 也可以反映两个变量变化时是同向还是反向，如果同向变化就为正，反向变化就为负。 由于除以了两个变量的标准差，消除了变化幅度的影响，只考虑变化率的相似程度 似然函数 Likehood function 似然函数 是关于统计模型中的参数的函数 给定输出 x 时，关于参数θ的似然函数L(θ|x)=P(X=x|θ) 概率描述了已知参数时的随机变量的输出结果；似然描述已知随机变量输出结果时，未知参数的可能取值 离散型 L(θ|x) = P(X=x|θ) 或 P(X=x;θ) 连续型 L(θ|x) = f(x|θ) 求极大似然函数 写出似然函数 对似然函数取对数 求导数 解似然方程]]></content>
      <categories>
        <category>mechine learning</category>
      </categories>
      <tags>
        <tag>statistic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[backtracking questions]]></title>
    <url>%2F2018%2F02%2F23%2Fbacktracking-questions%2F</url>
    <content type="text"><![CDATA[回溯法求幂集、排列组合、回文区分幂集无重复元素发幂集 Given a set of distinct integers, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. For example,If nums = [1,2,3], a solution is:[[3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 1234567891011121314151617def subsets(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ ans = [] l = len(nums) def backtrack(tempList, start): ans.append(tempList) for i in range(start, l): tempList.append(nums[i]) backtrack(tempList[:], i+1) tempList.pop() backtrack([], 0) return ans 存在重复元素的幂集 Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. or example,If nums = [1,2,2], a solution is: [[2], [1], [1,2,2], [2,2], [1,2], []] 123456789101112131415161718192021def subsetWithDup(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ l = len(nums) ans = [] nums = sorted(nums) tempList = [] def backtrack(start): ans.append(tempList[:]) for i in range(start, l): if i &gt; start and nums[i] == nums[i-1]: # skip duplicates continue tempList.append(nums[i]) backtrack(i+1) tempList.pop() backtrack(0) return ans 全排列问题无重复元素的全排列 Given a collection of distinct numbers, return all possible permutations. For example,[1,2,3] have the following permutations: [[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 12345678910111213141516171819202122def permute(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ l = len(nums) ans = [] tempList = [] def backtrack(): if len(tempList) == l: ans.append(tempList[:]) else: for i in range(l): if nums[i] in tempList: continue tempList.append(nums[i]) backtrack() tempList.pop() backtrack() return ans 存在重复元素的全排列 Given a collection of numbers that might contain duplicates, return all possible unique permutations. For example,[1,1,2] have the following unique permutations: [[1,1,2], [1,2,1], [2,1,1]] 1234567891011121314151617181920212223242526def permuteWithUnique(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ nums = sorted(nums) l = len(nums) ans = [] tempList = [] used = [False] * l def backtrack(): if len(tempList) == l: ans.append(tempList[:]) else: for i in range(l): if used[i] or i &gt; 0 and nums[i] == nums[i-1] and not used[i-1]: continue used[i] = True tempList.append(nums[i]) backtrack() used[i] = False tempList.pop() backtrack() return ans Input: [3, 3, 0, 3] Output: [[0, 3, 3, 3], [3, 0, 3, 3], [3, 3, 0, 3], [3, 3, 3, 0]] 组合问题元素可以用多次 Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. For example, given candidate set [2, 3, 6, 7] and target 7,A solution set is: [ [7], [2, 2, 3] ] 123456789101112131415161718192021222324def combinationSum(self, candidates, target): """ :type candidates: List[int] :type target: int :rtype: List[List[int]] """ ans = [] l = len(candidates) tempList = [] candidates = sorted(candidates) def backtrack(remain, start): if remain &lt; 0: return if remain == 0: ans.append(tempList[:]) else: for i in range(start, l): tempList.append(candidates[i]) backtrack(remain-candidates[i], i) tempList.pop() backtrack(target, 0) return ans 元素只能用一次 Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. Each number in C may only be used once in the combination. For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,A solution set is: [[1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] 1234567891011121314151617181920212223242526def combinationSum2(self, candidates, target): """ :type candidates: List[int] :type target: int :rtype: List[List[int]] """ l = len(candidates) ans = [] templist = [] candidates = sorted(candidates) def backtrack(remain, start): if remain &lt; 0: return if remain == 0: ans.append(templist[:]) else: for i in range(start, l): if i &gt; start and candidates[i] == candidates[i-1]: continue templist.append(candidates[i]) backtrack(remain - candidates[i], i+1) templist.pop() backtrack(target, 0) return ans 找回文子集 Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s. For example, given s = &quot;aab&quot;,Return [[&quot;aa&quot;,&quot;b&quot;], [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]] 1234567891011121314151617181920212223242526272829def partition(self, s): """ :type s: str :rtype: List[List[str]] """ l = len(s) ans = [] tempList = [] def isPalindrome(low, high): while low &lt; high: if s[low] != s[high]: return False low += 1 high -= 1 return True def backtrack(start): if start == l: ans.append(tempList[:]) else: for i in range(start, l): if isPalindrome(start, i): tempList.append(s[start: i+1]) backtrack(i+1) tempList.pop() backtrack(0) return ans summary: 我还没看懂… 以后再更新 -_-||| Copy from：https://leetcode.com/problems/subsets/discuss/27281/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java map-reduce]]></title>
    <url>%2F2018%2F02%2F11%2Fjava-map-reduce%2F</url>
    <content type="text"><![CDATA[Java开发Map/Reduce程序MR程序执行方式： 在本地运行，输入输出都在本地，用于调试程序 把远程数据拉到本地运行，输出传回远程，只适合数据量小 在远程运行，输入输出都在远程 Java程序在服务器上运行 配置系统环境变量HADOOP_HOME，指向hadoop安装目录（如果你不想招惹不必要的麻烦，不要在目录中包含空格或者中文字符） 把HADOOP_HOME/bin加到PATH环境变量（非必要，只是为了方便） 如果是在windows下开发，需要添加windows的库文件 把盘中共享的bin目录覆盖HADOOP_HOME/bin 如果还是不行，把其中的hadoop.dll复制到c:\windows\system32目录下，可能需要重启机器 maven引入依赖 新建项目，引入hadoop 所需要的jar文件 1234567891011121314151617181920212223242526&lt;properties&gt; &lt;project.build.sourceencoding&gt;UTF-8&lt;/project.build.sourceencoding&gt; &lt;hadoop.version&gt;2.7.3&lt;/hadoop.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-client&lt;/artifactId&gt; &lt;version&gt;$&#123;hadoop.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-common&lt;/artifactId&gt; &lt;version&gt;$&#123;hadoop.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-hdfs&lt;/artifactId&gt; &lt;version&gt;$&#123;hadoop.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 代码WordMapper.java1234567891011121314151617181920212223package com.zjm;import java.io.IOException;import org.apache.hadoop.io.IntWritable;import org.apache.hadoop.io.LongWritable;import org.apache.hadoop.io.Text;import org.apache.hadoop.mapreduce.Mapper;public class WordMapper extends Mapper&lt;LongWritable, Text, Text, IntWritable&gt;&#123; @Override protected void map(LongWritable key, Text value, Mapper&lt;LongWritable, Text, Text, IntWritable&gt;.Context context) throws IOException, InterruptedException &#123; final IntWritable ONE = new IntWritable(1); String s = value.toString(); String[] words = s.split(" "); for(String word: words) &#123; context.write(new Text(word), ONE); &#125; &#125; &#125; WordReduce.java12345678910111213141516171819202122package com.zjm;import java.io.IOException;import org.apache.hadoop.io.IntWritable;import org.apache.hadoop.io.LongWritable;import org.apache.hadoop.io.Text;import org.apache.hadoop.mapreduce.Reducer;public class WordReducer extends Reducer&lt;Text, IntWritable, Text, LongWritable&gt;&#123; @Override protected void reduce(Text key, Iterable&lt;IntWritable&gt; values, Reducer&lt;Text, IntWritable, Text, LongWritable&gt;.Context context) throws IOException, InterruptedException &#123; long count = 0; for(IntWritable v: values) &#123; count += v.get(); &#125; context.write(key, new LongWritable(count)); &#125;&#125; main函数1234567891011121314151617181920212223242526272829303132333435363738package com.zjm;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.fs.Path;import org.apache.hadoop.io.IntWritable;import org.apache.hadoop.io.LongWritable;import org.apache.hadoop.io.Text;import org.apache.hadoop.mapreduce.Job;import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;public class Test &#123; public static void main(String[] args) throws Exception&#123; Configuration conf = new Configuration(); conf.set("fs.defaultFS", "hdfs://master:9000/"); // 将项目打包到项目跟目录下 conf.set("mapreduce.job.jar", "wc.jar"); conf.set("mapreduce.framework.name", "yarn"); conf.set("yarn.resourcemanager.hostname", "master"); conf.set("mapreduce.app-submission.cross-platform","true"); Job job = Job.getInstance(conf); job.setMapperClass(WordMapper.class); job.setReducerClass(WordReducer.class); job.setMapOutputKeyClass(Text.class); job.setMapOutputValueClass(IntWritable.class); // Reduce 的输出类型 job.setOutputKeyClass(Text.class); job.setOutputValueClass(LongWritable.class); FileInputFormat.setInputPaths(job, "/input/"); FileOutputFormat.setOutputPath(job, new Path("/output")); job.waitForCompletion(true); &#125;&#125; 注： win系统的hosts文件添加虚拟机的IP和主机名 配置hadoop在win系统的环境变量 Run as —— Run Configurations —— Arguments —— VM arguments: -DHADOOP_USER_NAME=root]]></content>
      <categories>
        <category>Big Data</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yarn&Map/Reduce]]></title>
    <url>%2F2018%2F02%2F09%2FYarn-Map-Reduce%2F</url>
    <content type="text"><![CDATA[分布式计算 设计原则：移动计算，不移动数据 Yarn Yarn: 资源调度 主从结构：ResourceManager 和 NodeManager ResourceManager 将任务分配给空闲的机器(slave)工作，NodeManager在slave中做具体的资源利用，RM管理NM yarn-site.xml的配置 修改ResourceManager和NodeManager的vim hadoop/etc/hadoop/yarn-site.xml 1234567891011121314&lt;property&gt; &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt; &lt;value&gt;master&lt;/value&gt;&lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.auxservices.mapreduce.shuffle.class&lt;/name&gt; &lt;value&gt;org.apache.hadoop.mapred.ShuffleHandler&lt;/value&gt;&lt;/property&gt; 启动yarn集群start-yarn.sh 访问8088端口 Map/Reduce 在 ResourceManager上配置mapred-site.xml 1234&lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt;&lt;/property&gt; 执行示例程序 1hadoop jar /usr/local/hadoop/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.3.jar wordcount /input/input.txt /output 查看运行结果 hadoop fs -text /output/part-r-00000 Map/Reduce 流程 input split 拆分（一行一行） map 映射（键值对） shuffle 派发（键值对派发到一个nodeManager） reduce 缩减（按键统计值的和） output]]></content>
      <categories>
        <category>Big Data</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java hdfs]]></title>
    <url>%2F2018%2F02%2F08%2Fjava-hdfs%2F</url>
    <content type="text"><![CDATA[Java程序访问HDFS导入所需的jar文件 12345678910111213&lt;!-- https://mvnrepository.com/artifact/org.apache.hadoop/hadoop-common --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-common&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.apache.hadoop/hadoop-hdfs --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-hdfs&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt;&lt;/dependency&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package dbfs;import java.io.FileInputStream;import java.math.BigDecimal;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.fs.FSDataOutputStream;import org.apache.hadoop.fs.FileStatus;import org.apache.hadoop.fs.FileSystem;import org.apache.hadoop.fs.Path;import org.apache.hadoop.io.IOUtils;public class HelloHDFS &#123; public static void main(String args[]) throws Exception &#123;// URL.setURLStreamHandlerFactory(new FsUrlStreamHandlerFactory());// URL url = new URL("hdfs://192.168.137.100:9000/hello.txt");// InputStream in = url.openStream();// IOUtils.copyBytes(in, System.out, 4096, true); Configuration conf = new Configuration(); conf.set("fs.defaultFS", "hdfs://192.168.137.100:9000"); // 修改hdfs配置参数值 conf.set("dfs.replication", "5"); FileSystem fileSystem = FileSystem.get(conf); // 判断路径是否存在 boolean success = fileSystem.exists(new Path("/zjm")); System.out.println(success); // 新建路径，注意如果已经存在同名目录会覆盖原目录x_x success = fileSystem.mkdirs(new Path("/zjm")); System.out.println(success); // 删除 success = fileSystem.delete(new Path("/zjm"), true); System.out.println(success); // 上传文件 FSDataOutputStream out = fileSystem.create(new Path("/test.data")); FileInputStream fis = new FileInputStream("F:learn/mashibing/hadoop/马士兵hadoop2.7入门_03.mp4"); IOUtils.copyBytes(fis, out, 4096, true); fileSystem.delete(new Path("/video"), true); // 上传文件：IO流可计算上传进度 FSDataOutputStream out = fileSystem.create(new Path("/video")); FileInputStream in = new FileInputStream("F:learn/mashibing/hadoop/马士兵hadoop2.7入门_03.mp4"); int total = in.available(); byte[] buf = new byte[4096]; int len = in.read(buf); int now = len; while(len != -1) &#123; // 上传百分比，保留小数点后两位 System.out.println(new BigDecimal((float)now/total*100).setScale(2, BigDecimal.ROUND_HALF_UP).doubleValue()); out.write(buf, 0, len); len = in.read(buf); now += len; &#125; in.close(); out.close(); // 查看文件结构 FileStatus[] statuses = fileSystem.listStatus(new Path("/")); for(FileStatus status: statuses) &#123; System.out.println(status.getPath()); System.out.println(status.getPermission()); System.out.println(status.getReplication()); &#125; &#125;&#125; 注：需要关闭权限检查，向hdfs-site.xml中添加并重启hdfs 1234&lt;property&gt; &lt;name&gt;dfs.permissions.enabled&lt;/name&gt; &lt;value&gt;false&lt;/value&gt;&lt;/property&gt; description: If “true”, enable permission checking in HDFS. If “false”, permission checking is turned off, but all other behavior is unchanged. Switching from one parameter value to the other does not change the mode, owner or group of files or directories.]]></content>
      <categories>
        <category>Big Data</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hadoop hdfs]]></title>
    <url>%2F2018%2F02%2F06%2Fhadoop-hdfs%2F</url>
    <content type="text"><![CDATA[在多台服务器上配置Hadoop 启动namenode和datanode hadoop-daemon.sh start namenode(datanode) 在master上检测datanode hdfs dfsadmin -report | more 在web页面观察hadoop集群情况 192.168.137.100:50070 集中管理Slaves 在/usr/local/hadoop/etc/hadoop下的slaves文件中添加slaves的主机名，在master中就可以管理其中的所有slaves，如： 123slave1slave2slave3 执行：start-dfs.sh，输入master, slave, secondaryNameNode的密码 为了避免输入多次的密码，在 /.ssh 下执行 ssh-keygen -t rsa 回车三次，发现.ssh下生成两个文件：id_ras （私钥）和 id_ras.pub（公钥） 从master发送公钥到master, slave1, slave2, slave3：ssh-copy-id master, ssh-copy-id slave1, ssh-copy-id slave2, ssh-copy-id slave3 以后ssh IP 就不用再输入密码了，再执行start-dfs.sh时就不用再次输入密码了 hdfs文件系统指令 hadoop fs -ls或hdfs dfs -ls 放置一个文件到hdfs中：hadoop fs -put file / 通过网页观察现象：http://192.168.137.100:50070/explorer.html#/ 指令： hadoop fs -mkdir /dirname hadoop fs -text /filename 查看文本文件内容 hadoop fs -rm /filename 配置参数 编写/hadoop/etc/hadoop/hdfs-site.xml eg: 修改复制的个数为2份（默认为3份）： 1234&lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;2&lt;/value&gt;&lt;/property&gt;]]></content>
      <categories>
        <category>Big Data</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hadoop配置环境及启动]]></title>
    <url>%2F2018%2F02%2F05%2Fhadoop-day1%2F</url>
    <content type="text"><![CDATA[VirtualBox启动虚拟机 host-only方式连接虚拟机 安装Hadoop 连接虚拟机 查看虚拟网卡的IP地址(assume:192.168.137.1)，VM设置网卡类型为host-only 设置ipv4地址：vim /etc/sysconfig/network-scripts/ifcfg-enp03 IPADDR=192.168.137.100 NETMASK=255.255.255.0 设置网关地址及域名解析：vim /etc/sysconfig/network NETWORKING=yes GATEWAY=192.168.137.1 DNS1=8.8.8.8 设置计算机上能上网的网卡共享网络给虚拟网卡 修改主机名 hostnamectl set-hostname master 重启network服务 service network restart 互相ping 虚拟机：ping 192.168.137.1 电脑：ping 192.168.137.100 安装Hadoop 打开Xftp上传jdk，hadoop安装文件至/usr/local目录下 安装jdk rpm -ivh jdk-8u91-linux-x64.rpm 解压hadoop cd local tar -xvf hadoop-2.7.3.tar.gz 发现local目录下多了hadoop-2.7.3的目录(改名为了方便：mv hadoop-2.7.3 haddop) 配置Hadoop JDK路径 cd hadoop/etc/hadoop vim hadoop-env.sh export JAVA_HOME=/usr/java/default 将hadoop执行命令添加到path环境变量里 vim /etc/profile 添加：export PATH=$PATH:/usr/local/hadoop/bin:/usr/local/hadoop/sbin 执行： source /etc/profile 以这台虚拟机做master，复制出三台虚拟机做slaver，配置IP和网关，改主机名分别为slave1, slave2, slave3 启动Hadoop配置所有虚拟机1234567cd /usr/local/hadoop/etc/hadoopvim core-site.xml # master管理结点，slave知道master&lt;!-- 在&lt;configuration&gt;内添加：--&gt;&lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://master:9000&lt;/value&gt;&lt;/property&gt; 修改所有虚拟机的host文件 vim /etc/hosts eg 1234192.168.137.100 master192.168.137.101 slave1192.168.137.102 slave2192.168.137.103 slave3 格式化namenode(仅master) hdfs namenode -format 启动namenode(仅master) hadoop-daeman.sh start namenode 输入jps，出现NameNode则namenode启动 启动datanode(slaver) hadoop-daemon.sh start datanode]]></content>
      <categories>
        <category>Big Data</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[laravel基础]]></title>
    <url>%2F2017%2F09%2F13%2Flaravel%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[安装错误 solution: 打开运行环境中的php.ini，用快速查找找到 extension=php_openssl.dll 此项，然后把该代码前面的分号去掉，最后重启运行环境，刷新页面 路由 作用: 将请求映射到程序（处理函数） laravel/app/Http/routes.php: 基础路由 123Route::get('basic1',function () &#123; return 'Hello World';&#125;); 多请求路由 123Route::match(['get','post'], 'multy', function () &#123; return 'multy';&#125;); 所有请求种类路由 123Route::any('allRequest',function() &#123; return 'all request';&#125;); 路由参数 123Route::get('user/&#123;id&#125;/&#123;name?&#125;',function ($id,$name=null) &#123; return 'User-id'.$id.'User-name:'.$name;&#125;)-&gt;where(['id'=&gt;'[0-9]+','name'=&gt;'[A-Za-z]+']); 路由别名 123Route::get('user/center',['as'=&gt;'center', function() &#123; return route('center');&#125;]); 路由群组 12345678Route::group(['prefix'=&gt;'member'], function ()&#123; Route::get('basic2',function() &#123; return 'Basic2'; &#125;); Route::get('user/center',['as'=&gt;'center', function() &#123; return route('center'); &#125;]);&#125;); 路由输出视图 123Route::get('view', function ()&#123; return view('welcome');&#125;); 控制器 laravel/app/Http/Controllers: 路由将请求发送给控制器，控制器处理请求并返回相应 路由和控制器中的方法关联： 1234567891011Route::get('member/info','MemberController@info');Route::get('member/info',['uses'=&gt;'MemberController@info']);Route::get('member/info',[ 'uses' =&gt; 'MemberController@info', 'as' =&gt; 'member_info']);Route::get('member/find/&#123;id&#125;','MemberController@find')-&gt;where('id','[0-9]+'); 控制器中有对应路由请求的函数： 12345678910111213141516171819namespace App\Http\Controllers;class MemberController extends Controller &#123; public function info() &#123; //return 'member-info'; return route('member_info'); &#125; // 接收请求参数 public function find($id) &#123; return 'member'.$id; &#125; // 返回一个视图，向视图中传递数据 public function toInfo() &#123; return view('member/info',[ 'name' =&gt; 'shaun', 'age' =&gt; 18 ]); &#125;&#125; 视图 laravel/resources/views: 控制器的方法返回一个视图，并传递参数给视图，视图使用模板解析展示数据 laravel 默认模板文件名为：xxx.blade.php 用 的形式获取变量值 模型 laravel/app: 123456789namespace App;use Illuminate\Database\Eloquent\Model;class Member extends Model &#123; public static function getMember() &#123; return 'member name is shaun'; &#125;&#125; 数据库操作DB facade 配置：laravel/config/database.php laravel/.env 使用 DB facade 实现 CURD 1234567891011121314151617181920212223namespace App\Http\Controllers;use Illuminate\Support\Facades\DB;class UserController extends Controller &#123; public function curd() &#123; // 返回是否插入成功 $bool = DB::insert('insert into user(name,sex,phone,email) VALUES(?,?,?,?) ', ['zcl','1','1365656556','zcl@163.com']); var_dump($bool); // 返回查询结果的数组 $users = DB::select('select* from user'); dd($users); // json格式 // 返回变动的数量 $num = DB::update('update user set age=? where name = ?', [18,'zjm']); var_dump($num); // 返回删除的条数 $num = DB::delete('delete from user where id=?', [3]); var_dump($num); &#125;&#125; 查询构造器 Laravel 查询构造器 (query builder) 提供接口，用来建立及执行数据库查找语法 使用 PDO 参数绑定，以保护应用程序免于 SQL 注入，传入的参数不需要额外转义特殊字符 基本可以满足所有的数据库操作 使用查询构造器新增数据 123456789101112131415161718// 返回bool插入是否成功DB::table('user')-&gt;insert([ 'name' =&gt; 'ms', 'sex' =&gt; '0', 'age' =&gt; '18', 'phone' =&gt; '13666666666', 'email' =&gt; 'maoshuo@gmail.com']);// 返回插入的 id$id = DB::table('user')-&gt;insertGetId([ 'name' =&gt; 'shaun', 'age' =&gt; 19]);// 插入多条记录，二维数组存放信息，返回boolDB::table('user')-&gt;insert([ ['name' =&gt; '张三', 'age' =&gt; 21], ['name' =&gt; '李四', 'age' =&gt; 22],]); 使用查询构造器更新数据 更新数据 自增自减 123456789101112// 返回受影响的行数$num = DB::table('user') -&gt;where('id',7) -&gt;update([ 'name' =&gt; 'zjm' ]);var_dump($num);// 自减同时更新子段值$num = DB::table('user') -&gt;where(['id'=&gt;7]) // -&gt;where('id',7) -&gt;decrement('age',3, ['name' =&gt; 'zjmhaha']); //increment 自增 decrement 自减var_dump($num); 使用查询构造器删除数据 delete trancate——清空表… 12345678$num = DB::table('user') -&gt;where('id',7) -&gt;delete();var_dump($num);$num = DB::table('user') -&gt;where('id', '&gt;=', 13) -&gt;delete();var_dump($num); 使用查询构造器查询数据 get()——获取结果集所有数据 first()——获取结果集中第一条 where()——查询条件，whereRaw()——多条件查询 pluck()——返回结果集中指定的字段 lists()——类似pluck select()——查询指定的字段 chunk() ——分页返回所有结果集 1234567891011121314151617181920212223242526272829public function search() &#123; // get() 获取表中所有数据 $users = DB::table('user')-&gt;get(); // first 获取结果集第一条 $users = DB::table('user') -&gt;orderBy('id','desc') // 倒序 -&gt;first(); $users = DB::table('user') -&gt;where('age','&gt;=',20) -&gt;get(); // 多条件查询 $users = DB::table('user') -&gt;whereRaw('id &gt;= ? and age &gt; ?', [2, 20]) -&gt;get(); // pluck 返回结果集中指定的字段 $name = DB::table('user')-&gt;pluck('name'); //$name = DB::table('user')-&gt;lists('name', 'id'); //dd($name); //select 查询指定的字段 $users = DB::table('user') -&gt;select('id','name','age') -&gt;get(); // chunk echo '&lt;pre&gt;'; $num = DB::table('user')-&gt;chunk(2, function($users) &#123; var_dump($users); &#125;); var_dump($num); &#125; 查询构造器中的聚合函数 count() max() min() avg() sum() 12345678// 聚合函数public function aggregate() &#123; $num = DB::table('user')-&gt;count(); $num = DB::table('user')-&gt;max('age'); $num = DB::table('user')-&gt;min('age'); $num = DB::table('user')-&gt;avg('age'); $num = DB::table('user')-&gt;sum('age');&#125; 数据库操作-Eloquent ORM 数据表和一个相对应的模型 (Model) 用于和数据表交互 查询构造器在ORM中依旧有应用 模型建立 laravel/app: 12345678910namespace App;use Illuminate\Database\Eloquent\Model;class Student extends Model &#123; // 指定表名，默认为 students protected $table = 'student'; // 指定id,默认为id protected $id = 'id';&#125; ORM 查询123456789101112131415161718192021public function orm() &#123; // 查询所有 $students = Student::all(); // 按主键查询 $student = Student::find(1); // 找不到id报错 $student = Student::findOrFail(2); // 查询构造器在ORM中使用 $students = Student::get(); $student = Student::where('age','&gt;',18) -&gt;orderBy('age','desc') -&gt;first(); dd($student); echo '&lt;pre&gt;'; Student::chunk(2, function ($students) &#123; var_dump($students); &#125;); $num = Student::count(); $max = Student::where('age','&gt;',18)-&gt;max('age'); var_dump($max); &#125; ORM中新增，自定义时间戳及批量赋值 通过模型新增数据（自定义时间戳） 使用模型的Create方法新增数据（批量赋值） 模型属性的定义，方法重写123456789101112131415161718192021222324252627namespace App;use Illuminate\Database\Eloquent\Model;class Student extends Model &#123; // 指定表名，默认为 students protected $table = 'student'; // 指定id,默认为id protected $id = 'id'; // 指定允许批量赋值的字段 protected $fillable = ['name', 'age']; // 指定不允许批量赋值的字段// protected $guarded = []; // 关闭created_at 和 updated_at public $timestamps = true; // 自意义返回时间戳 /*protected function getDateFormat() &#123; return time(); &#125;*/ // /*protected function asDateTime( $value ) &#123; return $value; &#125;*/&#125; 注：由于laravel自定义添加的created_at时间不是北京时间，可以将数据库 created_at字段类型改为 int，重写模型的 getDateFormat()方法，如果希望返回时间戳(数字形式)，再重写asDateTime()函数 四种常用的ORM新增1234567891011121314151617181920212223242526272829public function orm2() &#123; // 使用模型新增数据 /*$student = new Student(); $student-&gt;name = 'ms'; $student-&gt;age = 18; $bool = $student-&gt;save(); dd($bool);*/ /*$Student = Student::find(3); echo $Student-&gt;created_at.'&lt;br&gt;'; echo date('Y-m-d H:i:s', 1464509164);// 只对于数字时间戳*/ // 使用模型的Create方法新增数据，这里的属性必须为模型中指定允许批量赋值的字段 /*$student = Student::create([ 'name' =&gt; 'zjm', 'age' =&gt; 18 ]); dd($student);*/ //firstOrCreate() 按属性查找，没有找到则新加 /*$student = Student::firstOrCreate([ 'name' =&gt; 'zjm22333' ]); dd($student);*/ //firstOrNew() 按属性查找，没有则建立新的实例，自己调用save()保存 $student = Student::firstOrNew([ 'name' =&gt; 'zjm123123' ]); $student-&gt;save(); dd($student); &#125; 注： 使用模型的Create方法新增数据，这里的属性必须为模型中指定允许批量赋值的 使用Eloquent ORM修改数据 通过模型更新 结合查询语句 批量更新 1234567$student = Student::find(8);$student-&gt;name = 'shaun';$bool = $student-&gt;save();var_dump($bool);Student::where('id','&gt;',7)-&gt;update([ 'age' =&gt; 23]); 注： 使用ORM的save()方法更新子段必须使模型的主键和数据库表主键相同，包括大小写 模型中默认主键名：id 重写模型中主键名：protected $primaryKey = &#39;Id&#39;; 使用Eloquent ORM删除数据 通过模型删除 通过主键值删除 根据指定条件删除 123456789// 通过模型删除（没有会报错）$student = Student::find(9);$bool = $student-&gt;delete();// 通过主键删除,返回删除个数$num = Student::destroy(7);$num = Student::destroy(7,8,9);$num = Student::destroy([7,8,9]);// 条件删除$num = Student::where('id', '&gt;', 6)-&gt;delete(); Blade模板引擎Blade模板引擎简介及模板继承的使用 页面公共的部分提取出来形成一个父类，方便开发和维护 @section…@show @yield 12345@extends(&apos;layouts&apos;)&lt;!-- 继承 views下的基类视图 --&gt;@section(&apos;header&apos;) @parent &lt;!-- 父模板内容 --&gt; self_content@stop 基础语法及include的使用 在控制器中返回视图并传入参数 123return view('student.section1', [ 'name' =&gt; $name]); 在模板中输出参数值 1234567891011121314151617&gt; &#123;&#123; $name &#125;&#125;&gt; &lt;!-- 调用php函数，执行php代码 --&gt;&gt; &#123;&#123; time() &#125;&#125;&gt; &#123;&#123; date(&apos;Y-m-d H:i:s&apos;, time()) &#125;&#125;&gt; &#123;&#123; in_array($name, $arr) ? &apos;true&apos; : &apos;false&apos;&#125;&#125;&gt; &#123;&#123; var_dump($arr) &#125;&#125;&gt; &lt;!-- 存在输出，不存在输出默认 --&gt;&gt; &#123;&#123; isset($name) ? $name:&apos;default&apos; &#125;&#125;&gt; &lt;!-- 可简化为： --&gt;&gt; &#123;&#123; $name or &apos;default&apos; &#125;&#125;&gt; &lt;!-- 原样输出 --&gt;&gt; @&#123;&#123; $name &#125;&#125;&gt; &lt;!-- 模板中的注释：不在页面源码中显示 --&gt;&gt; &#123;&#123; -- 你的注释 -- &#125;&#125;&gt; &lt;!-- 引入子视图 --&gt;&gt; @include(&apos;student.common1&apos;)&gt; 流程控制123456789101112131415161718192021222324252627282930@if ($name == &apos;zzz&apos;) I&apos;m zzz@elseif($name == &apos;aaa&apos;) I&apos;m aaa@else ...@endif@if(in_array($name, $arr)) true@else false@endif@unless($name == &apos;zjm&apos;) &lt;!--if的取反--&gt; I&apos;m zjm@endunless@for($i=0; $i &lt; 10; $i++) &#123;&#123; $i &#125;&#125;@endfor @foreach($students as $student) &lt;p&gt;&#123;&#123; $student-&gt;name &#125;&#125;&lt;/p&gt; @endforeach@forelse($students as $student) &lt;p&gt;&#123;&#123; $student-&gt;name &#125;&#125;&lt;/p&gt; @empty &lt;p&gt;无数据&lt;/p&gt; @endforelse 模板中的URL url()——通过路由名字 action()——通过制定控制器的方法名 route()——通过路由别名 123&lt;a href="&#123;&#123; url('url) &#125;&#125;"&gt;&lt;/a&gt; &lt;a href="&#123;&#123; action('StudentController.urlTest') &#125;&#125;"&gt;&lt;/a&gt; &lt;a href="&#123;&#123; route('url') &#125;&#125;"&gt;&lt;/a&gt; `]]></content>
      <categories>
        <category>web服务</category>
      </categories>
      <tags>
        <tag>php框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求所有LCS的简单算法及矩阵搜索算法]]></title>
    <url>%2F2017%2F08%2F21%2FLCS%2F</url>
    <content type="text"><![CDATA[动态规划——最长公共子序列（LCS）背景知识 子序列： 原序列 X，将 X 中的元素组成新序列 Z，这些元素的先后位置与原序列相对一致，Z 是 X 的一个子序列 最长公共子序列： 若 Z 是 X 的子序列 , Z 也是 Y 的子序列，且不存在比 Z 更长的 X 和 Y 的公共子序列，则称 Z 是 X 和 Y 的最长公共子序列 ，记为 Z ∈LCS( X , Y) 。最长公共子序列往往不止一个 eg: X = { A，B，C，B，D，A，B }，Y = { B，D，C，A，B，A }，则 { B，C，B，A } 是 X 和 Y 的一条公共子序列，由于没有更长的公共子序列，故也是一条最长公共子序列 最长公共子序列的结构 在穷举法中，将 X 中所有子序列，检查它是否也是 Y 的子序列，确定是公共子序列后记录最长的公共子序列。设 X 有 m 个元素，则它的子序列有 2m个，穷举法需要指数时间 最长公共子序列具有最优子结构 设序列 X = { x1，x2，···，xm } 和 Y = { y1，y2，···，yn } 的最长公共子序列为 Z = { z1，z2，···，zk }，则 若 xm = yn，则 zk = xm = yn，且Zk-1 是 Xm-1 和 Yn-1 的最长公共子序列 若 xm ≠ yn，且 zk ≠ xm，则 Z 是 Xm-1 和 Y 的最长公共子序列 若 xm ≠ yn，且 zk ≠ yn，则 Z 是 X 和 Yn-1 的最长公共子序列 子问题的递归结构 如果从顶向下计算，将出现大量的子问题重叠…动态规划的基本思想是从低向上计算不同子问题，通过底部子问题的解，得出顶部问题的解。最终目的是得到最顶上问题的解。 建立两个矩阵 c 和 b，矩阵 c 用来存放 i, j 位置的最长公共子序列长度(简记为LCS长度)，矩阵 b 存放i, j 位置是由哪个方向来的，方便回溯 建立递归关系如下： c[i,j]={0,i=0 or j=0c[i−1,j−1]+1,i,j&gt;0 and xi=yjmax(c[i−1,j],c[i,j−1]),i,j&gt;0 and xi≠yjc[i,j]=\begin{cases} 0, &amp; i=0\ or\ j=0\\ c[i-1,j-1]+1,&amp;i,j&gt;0\ and\ x_i=y_j\\ max(c[i-1,j],c[i,j-1]), &amp;i,j&gt;0\ and\ x_i\ne y_j \end{cases} c[i,j]=​⎩​⎪​⎨​⎪​⎧​​​0,​c[i−1,j−1]+1,​max(c[i−1,j],c[i,j−1]),​​​i=0 or j=0​i,j&gt;0 and x​i​​=y​j​​​i,j&gt;0 and x​i​​≠y​j​​​​ b[i,j]={1,i,j&gt;0 and xi=yj2,i,j&gt;0 and xi≠yj and c[i−1,j]&gt;c[i,j−1]3,i,j&gt;0 and xi≠yj and c[i−1,j]≤c[i,j−1] b[i,j]=\begin{cases} 1,&amp;i,j&gt;0\ and\ x_i=y_j\\ 2, &amp;i,j&gt;0\ and\ x_i\ne y_j\ and\ c[i-1,j]&gt;c[i,j-1]\\ 3, &amp;i,j&gt;0\ and\ x_i\ne y_j\ and\ c[i-1,j]\leq c[i,j-1] \end{cases} b[i,j]=​⎩​⎪​⎨​⎪​⎧​​​1,​2,​3,​​​i,j&gt;0 and x​i​​=y​j​​​i,j&gt;0 and x​i​​≠y​j​​ and c[i−1,j]&gt;c[i,j−1]​i,j&gt;0 and x​i​​≠y​j​​ and c[i−1,j]≤c[i,j−1]​​ 图中右下角 5(2) 表示 (8, 8) 位置的LCS长度为5，由上面的位置 (7, 8) 得到 右下角的值就是LCS长度，从该点通过矩阵 b 回溯，遇到 2 向上走，遇到 3 向左走，遇到 1 斜上走，当遇到边缘时(i=0 或 j=0)停止，既可以得到一条最长公共子序列 这样做只能得到两串的一条最长公共子序列，因为当 c[i−1,j]=c[i,j−1] 时可以向上也可以向左，但是我们指定它向左了，这样就不会出现不同的情况。于是，可以添加一种 b 的值： b[i,j]=4, i,j&gt;0 and xi≠yj and c[i−1,j]=c[i,j−1]b[i,j]=4,\ \ \ \ i,j&gt;0\ and\ x_i\ne y_j\ and\ c[i-1,j]=c[i,j-1]b[i,j]=4, i,j&gt;0 and x​i​​≠y​j​​ and c[i−1,j]=c[i,j−1] 当 b[i][j] = 4 时(下文称为分叉点)，向上走也向左走，这样可以遍历到所有的路径 如图，当遇到分叉点的时候将分出两个路径，将所有分叉点作为非叶子结点组成一棵二叉树： 最下面的叶子结点个数就是所有路径个数 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;set&gt;using namespace std;int num = 0; // 记录遍历路径数int** getArr(int,int); // 动态创建二维数组void LCS(int**,int**,string,string,int,int); // 给 c,b 数组赋值void TraceBack(string,string,int**,int,int); // 回溯路径set&lt;string&gt; setOfLCS; // set保存所有的LCS，set集合中元素不重复int main() &#123; string s1,s2; cin&gt;&gt;s1&gt;&gt;s2; int len1 = s1.size() + 1; int len2 = s2.size() + 1; int** c = getArr(len1,len2); int** b = getArr(len1,len2); // 使 s1,s2 与 c,b 坐标一致 s1 = " " + s1; s2 = " " + s2; // 自底向上给 c,b 数组赋值 LCS(c,b,s1,s2,len1,len2); // 显示 c,b 数组 for(int i=0;i&lt;len1;i++) &#123; for(int j=0;j&lt;len2;j++) &#123; cout&lt;&lt;c[i][j]&lt;&lt;" "; if(j == len2-1) cout&lt;&lt;endl; &#125; &#125; cout&lt;&lt;"===============================\n"; for(int i=0;i&lt;len1;i++) &#123; for(int j=0;j&lt;len2;j++) &#123; cout&lt;&lt;b[i][j]&lt;&lt;" "; if(j == len2-1) cout&lt;&lt;endl; &#125; &#125; // 从右下角根据 b 数组指向回溯到边界 TraceBack(s1,"",b,len1-1,len2-1); cout&lt;&lt;"All route number: "&lt;&lt;num&lt;&lt;endl; cout&lt;&lt;"Remove duplicate elements: "&lt;&lt;endl; // 遍历set，输出所有LCS set&lt;string&gt;::iterator iter=setOfLCS.begin(); while(iter != setOfLCS.end()) &#123; cout&lt;&lt;*iter&lt;&lt;endl; iter++; &#125; cout&lt;&lt;"LCS length: "&lt;&lt;c[len1-1][len2-1]&lt;&lt;endl; cout&lt;&lt;"LCS number: "&lt;&lt;setOfLCS.size()&lt;&lt;endl; return 0;&#125;void LCS(int** c,int** b,string s1,string s2,int m,int n) &#123; for(int i=1;i&lt;m;i++) &#123; for(int j=1;j&lt;n;j++) &#123; if(s1[i] == s2[j]) &#123; c[i][j] = c[i-1][j-1] + 1; b[i][j] = 1; // 斜上 &#125; else if(c[i-1][j] &gt; c[i][j-1]) &#123; c[i][j] = c[i-1][j]; b[i][j] = 2; // 上 &#125; else if(c[i-1][j] &lt; c[i][j-1]) &#123; c[i][j] = c[i][j-1]; b[i][j] = 3; // 左 &#125; else &#123; c[i][j] = c[i-1][j]; b[i][j] = 4; // 上 或 左 &#125; &#125; &#125;&#125;// 返回动态创建的二维数组的指针int** getArr(int M,int N) &#123; int** arr = new int*[M]; for(int i=0;i&lt;M;i++) &#123; arr[i] = new int[N]; memset(arr[i],0,sizeof(int)*N); &#125; return arr;&#125;void TraceBack(string s1,string temp,int** b,int i,int j) &#123; while(i&gt;0 &amp;&amp; j&gt;0) &#123; if(b[i][j] == 1) &#123; temp = s1[i] + temp; i--; j--; &#125; else if(b[i][j] == 2) &#123; i--; &#125; else if(b[i][j] == 3) &#123; j--; &#125; else &#123; // 递归回溯 TraceBack(s1,temp,b,i-1,j); TraceBack(s1,temp,b,i,j-1); return; &#125; &#125; num ++; // 打印一次遍历得到的字符串，可能是重复的 cout&lt;&lt;"###"&lt;&lt;temp&lt;&lt;endl; // 交给 set 来移除重复字符串 setOfLCS.insert(temp);&#125; 输入 12badcdcbaabcdcdab 得到的结果为：LCS长度=5，总路径数=18，除去重复的子串后，所有LCS个数为8 可以发现：回溯过程中不同路径出现大量交叉，由于总路径数是二叉树的叶子结点数，最坏情况下，二叉树高度为max(m,n)，即两串长度最大值，叶子结点个数为2max(m,n)，这些情况中还存在大量重复，筛选很麻烦，最后结果可能得到很少的几组数据而已。 优化：矩阵搜索求所有的最长公共子序列 鉴于上述方法的缺点，根据《利用矩阵搜索求所有最长公共子序列的算法》，宫洁卿，安徽工程科技学院学报，vol23,No.4,Dec.,2008 提出的思想，这里进行简要阐述： 将 b[i][j] = 1 的点称为跳跃点，跳跃点使LCS从n→n-1(n=1,2,…,LCS长度)，LCS是由一条路径上的跳跃点对应的字符组成。将n→n-1的每个跳跃点依次找到这个点的所有下一跳跃点，直到没有下一个跳跃点为止。 矩阵搜索算法的基本思路和步骤 两个栈：第一个栈 store 用于存放所有搜索到的元素，当该栈为空时，运算结束；第二个栈 print 用于存放准备打印的元素。先计算出二维数组 C，每个节点都纪录本节点所在的坐标，LCS 长度和指向的方向。假设该 LCS 串最长为 n，那么虚拟一个( n + 1) →n的节点，该节点的坐标位于数组 C 最右下角的节点 C[ i , j ] 的右下方，为 C[ i + 1 , j + 1 ]。将该节点压入栈 store 检测栈 store 是否为空，如果为空，则本算法结束 从 store 栈顶取出一个节点压入 print 栈 如果当前的元素是边界元素1 →0 时，打印栈 print 里面除了栈底的所有元素(无须打印原本不存在的虚拟结点) 。查看 store 栈里最上面一个元素的 LCS 长度，弹出栈 print 里面所有LCS 长度比 store 栈最上面的 LCS 长度大或相等的元素，跳转到第 2 步 设该结点的 LCS 长度为 n +1，从该节点出发，查看该节点的方向箭头，按照斜方向路线、向上的路线（如果是双向的路线则走向上的路线）、向左的路线为优先级找到一个 n → ( n - 1) 的节点，假设为C[ X1 , Y1 ] 再次从该节点出发，查看该节点的方向箭头 ,按照斜方向路线、向左的路线（如果是双向的路线则走向左的路线） 、向上的路线为优先级找到一个 n →( n - 1) 的节点 ,假设为 C[ X2 , Y2 ] 比较 C[ X1 , Y1 ] 和 C[ X2 , Y2 ] 这两个节点。如果这两个结点是同一个结点，则将该结点压入栈 store，跳转到第 2 步 从刚才得到的两个结点 C[ X1 , Y1 ] 和 C[ X2 , Y2 ]，在二维数组 C 中，以 ( X1 , Y1 ) ( X2 , Y1 ) ( X1 ,Y2 ) ( X2 , Y2 ) 这四个点为坐标所构成的矩阵，在该矩阵中搜索所有的元素，将所有满足 n →( n - 1) 的节点压入栈 store。跳转到第 2 步 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;stack&gt;using namespace std;int** getArr(int,int);void LCS(int**,int**,string,string,int,int);void TraceBack(int,int,int**,int**,string);struct node &#123; int x; int y; int lcsLen; node()&#123;&#125; node(int x,int y,int z):x(x),y(y),lcsLen(z)&#123;&#125; node(int x,int y,int** c):x(x),y(y),lcsLen(c[x][y])&#123;&#125; bool operator ==(const node &amp;n) &#123; if(this-&gt;x == n.x &amp;&amp; this-&gt;y == n.y) return true; return false; &#125;&#125;;void printStack(stack&lt;node&gt;,string);void popPrint(stack&lt;node&gt;&amp;,int);node findJump(int,int,int**,int**,int);void searchMatrix(node,node,int**,int**,stack&lt;node&gt;&amp;);int main()&#123; string s1,s2; cout&lt;&lt;"Input the first Sequence:"; cin&gt;&gt;s1; cout&lt;&lt;"Input the second Sequence:"; cin&gt;&gt;s2; int len1 = s1.length()+1; int len2 = s2.length()+1; int** c = getArr(len1,len2); int** b = getArr(len1,len2); s1 = " " + s1; s2 = " " + s2; LCS(c,b,s1,s2,len1,len2); for(int i=0;i&lt;len1;i++) &#123; for(int j=0;j&lt;len2;j++) &#123; cout&lt;&lt;c[i][j]&lt;&lt;" "; if(j == len2-1) cout&lt;&lt;endl; &#125; &#125; cout&lt;&lt;"===============================\n"; for(int i=0;i&lt;len1;i++) &#123; for(int j=0;j&lt;len2;j++) &#123; cout&lt;&lt;b[i][j]&lt;&lt;" "; if(j == len2-1) cout&lt;&lt;endl; &#125; &#125; if(c[len1-1][len2-1] == 0) &#123; cout&lt;&lt;"0 0"&lt;&lt;endl; return 0; &#125; TraceBack(len1,len2,c,b,s1); return 0;&#125;int** getArr(int M,int N) &#123; int** arr = new int*[M]; for(int i=0;i&lt;M;i++) &#123; arr[i] = new int[N]; memset(arr[i],0,sizeof(int)*N); &#125; return arr;&#125;void LCS(int** c,int** b,string s1,string s2,int m,int n) &#123; for(int i=1;i&lt;m;i++) &#123; for(int j=1;j&lt;n;j++) &#123; if(s1[i] == s2[j]) &#123; c[i][j] = c[i-1][j-1] + 1; b[i][j] = 1; &#125; else if(c[i-1][j] &gt; c[i][j-1]) &#123; c[i][j] = c[i-1][j]; b[i][j] = 2; &#125; else if(c[i-1][j] &lt; c[i][j-1]) &#123; c[i][j] = c[i][j-1]; b[i][j] = 3; &#125; else &#123; c[i][j] = c[i-1][j]; b[i][j] = 4; &#125; &#125; &#125;&#125;void TraceBack(int m,int n,int** c,int** b,string str) &#123; stack&lt;node&gt; store, print; node virtualNode = node(m,n,c[m-1][n-1]+1); //由虚拟结点引发循环 store.push(virtualNode); node storeTop; int topLen,number=0; while(!store.empty()) &#123; storeTop = store.top(); store.pop(); print.push(storeTop); // 判断弹出的元素是否是边界元素 if(storeTop.x == 1 || storeTop.y == 1 || print.size() == c[m-1][n-1]+1) &#123; number++; printStack(print,str); // 是边界将print栈除虚拟结点的所有点打印 cout&lt;&lt;endl; // 数量太多不要输出这两行了 if(!store.empty()) &#123; topLen = store.top().lcsLen; popPrint(print,topLen); // 弹出小于等于store栈顶长度的print栈中的点 &#125; &#125; else &#123; //不是边界说明还有下一跳 int x = storeTop.x; int y = storeTop.y; node e1 = findJump(x-1,y-1,b,c,0); node e2 = findJump(x-1,y-1,b,c,1); if(e1 == e2) &#123; store.push(e1); &#125; else &#123; searchMatrix(e1,e2,c,b,store); &#125; &#125; &#125; cout&lt;&lt;number&lt;&lt;endl;&#125;// 输出print栈中所有元素void printStack(stack&lt;node&gt; s,string str) &#123; while(!s.empty()) &#123; cout&lt;&lt;str[s.top().x]; s.pop(); &#125;&#125;// 弹出print栈中长度小于等于n的元素，相当于回到前一跳的状态void popPrint(stack&lt;node&gt; &amp;s,int n) &#123; // 由于进入print栈点的lcsLen值是单调减，直接出栈直到lcsLen大于n，最底下的虚拟结点不能出栈 while(s.top().lcsLen &lt;= n &amp;&amp; s.size() != 1) &#123; s.pop(); &#125;&#125;// 寻找所有下一跳，type为真：遇到跳跃点向左走，type为假：遇到跳跃点向上走，直到找到第一个跳跃点node findJump(int x,int y,int** b,int** c,int type) &#123; if(type) &#123; while(b[x][y] != 1)&#123; // 这里一定有下一个跳跃点，不用担心会找不到而越界 if(b[x][y] == 2) x--; else y--; &#125; &#125; else &#123; while(b[x][y] != 1)&#123; if(b[x][y] == 3) y--; else x--; &#125; &#125; return node(x,y,c);&#125;// 如果findJump找到的两个下一跳跃点不是一个点，则以这两个点为矩形搜索里面的跳跃点，视为下一跳跃点加入store栈中void searchMatrix(node e1,node e2,int** c,int** b,stack&lt;node&gt;&amp; store) &#123; int x1 = e1.x; int y1 = e1.y; int x2 = e2.x; int y2 = e2.y; int temp; if(x1 &gt; x2) &#123; temp = x1; x1 = x2; x2 = temp; &#125; if(y1 &gt; y2) &#123; temp = y1; y1 = y2; y2 = temp; &#125; for(int i=x2;i&gt;=x1;i--) &#123; for(int j=y2;j&gt;=y1;j--) &#123; if(b[i][j] == 1) store.push(node(i,j,c)); &#125; &#125;&#125; 根据算法的思想实现了代码，经过以下数据对直接遍历和矩阵搜索进行对比： ABCDCDABCDBADCDCBADC ABCDCDABCDABCDCDABCDBADCDCBADCBADCDCBADC ABCDCDABCDABCDCDABCDABCDCDABCDBADCDCBADCBADCDCBADCBADCDCBADC ABCDCDABCDABCDCDABCDABCDCDABCDABCDCDABCDBADCDCBADCBADCDCBADCBADCDCBADCBADCDCBADC 测试用例编号 LCS长度 所有LCS个数 直接遍历循环次数 1 6 20 60 2 12 700 7560 3 18 25460 970200 4 24 936540 没测出来 当字符串长度40时，简单的遍历所有路径就无法短时间显示结果了]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Prim-Kruscal]]></title>
    <url>%2F2017%2F08%2F13%2FPrim-Kruscal%2F</url>
    <content type="text"><![CDATA[贪心算法——最小生成树 G=(V,E) 是连通带权图，E 中每条边 (v,w) 的权为 c[v][w]，G 的一个子图 G’ 是一颗包含 G 的所有顶点的树，则称 G’ 为 G 的生成树，所有生成树中权值和最小的称为 G 的最小生成树 MST 性质：设 G=(V,E) 是连通带权图，U 是 V 中的一个真子集，若存在顶点 u∈U 和顶点 v∈V-U 的边（u，v）是一条具有最小权值的边，则必存在 G 的一棵最小生成树包括这条边（u，v） Prim 和 Kruscal 都应用最小生成树的 MST 性质进行贪心选择 实例中连通带权图为 图的表示：邻接矩阵——使用二维数组存放两点之间的信息 Prim 算法 设 G=(V,E) 是连通带权图，V = {1,2,…,n} 构造 G 的最小生成树的 Prim算法的基本思想是：首先置 S={1}，然后只要 S 是 V 的真子集，就做如下贪心选择：选取满足条件 i∈S，j∈V-S，且 c[i][j] 最小的边，并将顶点 j 添加到 S 中，这个过程一直进行到 S=V为止。这个过程中选取的所有边构成 G 的一颗最小生成树 Question: 如何有效地找出满足 i∈S, j∈V-S，且权 c[i][j] 最小的边 (i,j) ? 代码说明： 对于每个 j∈V-S，closest[j] 是 j 在 S 中的临界顶点，它与 j 在 S 中的其他临接顶点 k 相比较有： c[j][closest[j]]≤c[j][k] lowest[j] 的值就是 c[j][closest[j]] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;stdio.h&gt;#define MIN 100001int Prim(int[100][100],int);int main() &#123; int N; int arr[100][100]; // 存放两点之间连线的权值 while(~scanf("%d",&amp;N)) &#123; // 输入 for(int i=0;i&lt;N;i++) &#123; for(int j=0;j&lt;N;j++) &#123; scanf("%d",&amp;arr[i][j]); &#125; &#125; // Prim printf("最小生成树权值和：%d\n",Prim(arr,N)); &#125; return 0;&#125;// lowcost[i]:V-S中点i到S中的点连线最小权值// closet[i]:V-S中点i到s中权值最小连线应该连的点坐标int Prim(int c[100][100],int N) &#123; int lowcost[N],closest[N], res=0; bool s[N]; // S 集合最开始只有0号元素时，对lowcost, clostest初始化 s[0] = true; for(int i=1;i&lt;N;i++) &#123; lowcost[i] = c[i][0]; // 最开始 S 中只有 0 closest[i] = 0; s[i] = false; &#125; // 将 V-S 集合中的元素放到 S 中 for(int i=1;i&lt;N;i++) &#123; int k, imin = MIN; for(int j=1;j&lt;N;j++) &#123; if(!s[j] &amp;&amp; lowcost[j] &lt; imin) &#123; imin = lowcost[j]; k = j; &#125; &#125; s[k] = true; printf("%d--%d \n",k,closest[k]); res += imin; // 由于 S 中有了一个新的元素，V-S 中各点 lowcost 值可能发生变化 for(int j=1;j&lt;N;j++) &#123; if(!s[j] &amp;&amp; lowcost[j] &gt; c[j][k]) &#123; lowcost[j] = c[j][k]; closest[j] = k; &#125; &#125; &#125; return res;&#125;/*Input:40 4 9 214 0 8 179 8 0 1621 17 16 0*/ Kruscal 算法 先构造一个只含 n 个顶点、而边集为空的子图，把子图中各个顶点看成各棵树上的根结点，之后，从网的边集 E 中选取一条权值最小的边，若该条边的两个顶点分属不同的树，则将其加入子图，即把两棵树合成一棵树，反之，若该条边的两个顶点已落在同一棵树上，则不可取，而应该取下一条权值最小的边再试之。依次类推，直到森林中只有一棵树，也即子图中含有 n-1 条边为止 简单的说： Kruscal 算法先找权值最小的边，检查这条边两个端点是否在一个集合中，如果不在一个集合中，连接两点(合并点所在集合)后找下一条权值最小的边；如果在一个集合，不连接两点直接找下一条权值最小的边，直到连接的边数为n-1为止 Question: 怎样按权递增的顺序查看各边？ 怎样判断两点是否在一个集合中？ 优先队列和并查集 优先队列请见 priority-queue 并查集（Union-find Sets）主要用于处理一些不相交集合 的合并问题，使用树形结构表示一个集合，树的每个节点就表示集合中的一个元素，树根作为集合的代表。 并查集的基本操作有三个： makeSet(s)：建立一个新的并查集，其中包含 s 个单元素集合。 unionSet(x, y)：把元素 x 和元素 y 所在的集合合并，要求 x 和 y 所在的集合不相交，如果相交则不合并。 find(x)：找到元素 x 所在的集合的代表，该操作也可以用于判断两个元素是否位于同一个集合，只要将它们各自的代表比较一下就可以了。在find方法中，如果每次都沿着父节点向上查找，当树很高时，会降低查找效率（时间复杂度就是树的高度）有一种非常简单而有效的策略——路径压缩： 路径压缩，就是在每次查找时，令查找路径上的每个节点都直接指向根节点 这样查看每个元素所在树的根节点只需要一步 并查集的合并：将一个集合的树根指向另一个集合的树根 ​合并策略——按秩合并：用秩表示树的高度，在合并时，总是将具有较小秩的树根指向具有较大秩的树根。简单的说，就是总是将比较矮的树作为子树，添加到较高的树中。代码中 urank[x] 表示 x 为根的树的高度 使用优先队列将边升序排列（注意对自定义类型要重写 ‘&lt;’ 运算符） 使用并查集判断两点是否在一个集合上（根节点是否相等），合并两集合 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&lt;stdio.h&gt;#include&lt;queue&gt;#define MAXSIZE 100using namespace std;int arr[MAXSIZE][MAXSIZE];int uset[MAXSIZE]; // uset[i] :元素i所属集合的根节点int urank[MAXSIZE]; // urank[i] :元素i为根节点集合的高度int Kruscal(int);int res = 0;struct Edge &#123; int x; int y; int weight; Edge(int x,int y,int weight) &#123; this-&gt;x = x; this-&gt;y = y; this-&gt;weight = weight; &#125; friend bool operator &lt; (Edge edge1, Edge edge2) &#123; return edge1.weight &gt; edge2.weight; &#125;&#125;;priority_queue&lt;Edge&gt; q;int main() &#123; int N; while(~scanf("%d",&amp;N)) &#123; res = 0; // 输入 for(int i=0;i&lt;N;i++) &#123; for(int j=0;j&lt;N;j++) &#123; scanf("%d",&amp;arr[i][j]); &#125; &#125; // 将边放入优先队列中 for(int i=0;i&lt;N-1;i++) &#123; for(int j=i+1;j&lt;N;j++) &#123; q.push(Edge(i,j,arr[i][j])); &#125; &#125; Kruscal(N); printf("%d\n",res); &#125; return 0;&#125;void makeSet(int N) &#123; // 初始时每个元素独立成为一个集合，根节点是本身，集合（树）高度为0 for(int i=0;i&lt;N;i++) &#123; uset[i] = i; urank[i] = 0; &#125;&#125;int findRoot(int x) &#123; // 只有根节点的父节点是本身 if(uset[x] == x) &#123; return x; &#125; // 不是根节点递归寻找根节点，找到后赋值给uset[x]减少下次递归的次数，相当于压缩了到根节点的路径 return uset[x] = findRoot(uset[x]);&#125;bool unionSet(int x,int y) &#123; // 取 x,y 所在集合的根节点 x=findRoot(x); y=findRoot(y); // x,y 属于一个集合，不可合并 if(x == y) &#123; return false; &#125; // x,y 不在同一集合，将高度小的集合加到高度大的集合根节点 else if(urank[x] &gt; urank[y]) &#123; // y 集合的根节点的父亲是 x 集合的根节点 uset[y] = x; &#125; else &#123; uset[x] = y; // 高度相等，x所在集合根节点接到y集合根节点，y集合高度加一 if(urank[x] == urank[y]) &#123; urank[y]++; &#125; &#125; return true;&#125;int Kruscal(int N) &#123; makeSet(N); int qsize = q.size(); int lineNum = 0; for(int i=0;i&lt;qsize;i++) &#123; // e为当前最小权值边 Edge e = q.top(); // 按权值降序处理每一条边，如果两点不在一个集合中，合并两点所在的集合返回true，说明生成了一条连线 if(unionSet(e.x, e.y)) &#123; lineNum ++; res += arr[e.x][e.y]; printf("%d--%d\n",e.x,e.y); // 连线数 = 点数 - 1 时为最小生成树，结束循环 if(lineNum == N - 1) &#123; break; &#125; &#125; q.pop(); &#125;&#125;/*Input:40 4 9 214 0 8 179 8 0 1621 17 16 0*/]]></content>
      <categories>
        <category>算法</category>
        <category>OJ 做题知识点积累</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot-mybatis小程序]]></title>
    <url>%2F2017%2F04%2F09%2Fspringboot-mybatis%2F</url>
    <content type="text"><![CDATA[IntelliJ开发SpringBoot-Mybatis应用程序新建工程 new Project——Spring Initializr 填好工程Name，包路径Group,Package Dependencies页面勾选Web，Mybatis，Mysql会自动帮你生产maven的pom文件，当然也可以自己后往里添加，maven会自动的帮你下载需要的依赖 Finish 注： maven默认中央仓库在国外可能使下载依赖很慢，可以修改maven的conf/settings.xml更换镜像地址： 123456&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 工程结构说明 main-java 目录下的 *Application 类是项目的启动类 main 下的 application.yml 是配置文件 test 是测试类的目录 pom.xml 是 maven 的依赖管理文件 配置文件配置文件有 .properties 和 .yml 两种，格式不同而已，下面的是 .yml 1234567891011121314151617181920212223242526272829303132333435363738#serverserver: port: 80#spring configspring: aop: auto: true datasource: name: * url: jdbc:mysql://localhost:3306/* driverClassName: com.mysql.jdbc.Driver username: * password: * type: com.alibaba.druid.pool.DruidDataSource maxActive: 1000 initialSize: 5 maxWait: 60000 minIdle: 1 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true maxOpenPreparedStatements: 20# MyBatismybatis: type-aliases-package: com.zjm.model mapper-locations: classpath:/mapper/*.xml configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl#PageHelperpagehelper: offsetAsPageNum: true rowBoundsWithCount: true reasonable: true 编写Mybatis 小程序准备 在上面的配置文件中 Mybatis 的配置项里 type-aliases-package：是对象类的路径 (main.java.com.*.model下) mapper-locations：是对象dao类对应的 .xml 的路径 (main.resource.mapper下) 建立以上路径及com.*.dao 在pom.xml中加入依赖：(在标签中) 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.20&lt;/version&gt;&lt;/dependency&gt; 在*Application.java文件的类上加入 @MapperScan(basePackages = “com.zjm.dao”) @SpringBootApplication 这两个注解 12345678@MapperScan(basePackages = "com.zjm.dao")@SpringBootApplicationpublic class IshopApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(IshopApplication.class, args); &#125;&#125; 代码User123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package com.zjm.model;import java.util.Date;public class User &#123; private Integer id; private String nickname; private String password; private String phone; private String email; private Date regdate; private Integer sex; private String head; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getNickname() &#123; return nickname; &#125; public void setNickname(String nickname) &#123; this.nickname = nickname == null ? null : nickname.trim(); &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password == null ? null : password.trim(); &#125; public String getPhone() &#123; return phone; &#125; public void setPhone(String phone) &#123; this.phone = phone == null ? null : phone.trim(); &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email == null ? null : email.trim(); &#125; public Date getRegdate() &#123; return regdate; &#125; public void setRegdate(Date regdate) &#123; this.regdate = regdate; &#125; public Integer getSex() &#123; return sex; &#125; public void setSex(Integer sex) &#123; this.sex = sex; &#125; public String getHead() &#123; return head; &#125; public void setHead(String head) &#123; this.head = head == null ? null : head.trim(); &#125; @Override public String toString() &#123; return "User&#123;" + "id=" + id + ", nickname='" + nickname + '\'' + ", password='" + password + '\'' + ", phone='" + phone + '\'' + ", email='" + email + '\'' + ", regdate=" + regdate + ", sex=" + sex + ", head='" + head + '\'' + '&#125;'; &#125;&#125; UserMapper12345678910111213141516171819package com.zjm.dao;import com.zjm.model.User;public interface UserMapper &#123; int deleteByPrimaryKey(Integer id); int insert(User record); int insertSelective(User record); User selectByPrimaryKey(Integer id); int updateByPrimaryKeySelective(User record); int updateByPrimaryKey(User record);&#125; UserMapper.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.zjm.dao.UserMapper"&gt; &lt;resultMap id="BaseResultMap" type="com.zjm.model.User"&gt; &lt;id column="Id" jdbcType="INTEGER" property="id" /&gt; &lt;result column="nickName" jdbcType="VARCHAR" property="nickname" /&gt; &lt;result column="password" jdbcType="VARCHAR" property="password" /&gt; &lt;result column="phone" jdbcType="VARCHAR" property="phone" /&gt; &lt;result column="email" jdbcType="VARCHAR" property="email" /&gt; &lt;result column="regDate" jdbcType="DATE" property="regdate" /&gt; &lt;result column="sex" jdbcType="INTEGER" property="sex" /&gt; &lt;result column="head" jdbcType="VARCHAR" property="head" /&gt; &lt;/resultMap&gt; &lt;sql id="Base_Column_List"&gt; Id, nickName, password, phone, email, regDate, sex, head &lt;/sql&gt; &lt;select id="selectByPrimaryKey" parameterType="java.lang.Integer" resultMap="BaseResultMap"&gt; select &lt;include refid="Base_Column_List" /&gt; from user where Id = #&#123;id,jdbcType=INTEGER&#125; &lt;/select&gt; &lt;select id="selectUserByExample" parameterType="User" resultMap="BaseResultMap"&gt; SELECT &lt;include refid="Base_Column_List" /&gt; FROM USER &lt;where&gt; &lt;if test="id != null"&gt; Id = #&#123;id&#125; &lt;/if&gt; &lt;if test="nickname != null"&gt; nickName = #&#123;nickname&#125; &lt;/if&gt; &lt;if test="password != null"&gt; password = #&#123;password&#125; &lt;/if&gt; &lt;if test="phone != null"&gt; phone = #&#123;phone&#125; &lt;/if&gt; &lt;if test="email != null"&gt; email = #&#123;email&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; &lt;delete id="deleteByPrimaryKey" parameterType="java.lang.Integer"&gt; delete from user where Id = #&#123;id,jdbcType=INTEGER&#125; &lt;/delete&gt; &lt;insert id="insert" parameterType="com.zjm.model.User"&gt; insert into user (Id, nickName, password, phone, email, regDate, sex, head) values (#&#123;id,jdbcType=INTEGER&#125;, #&#123;nickname,jdbcType=VARCHAR&#125;, #&#123;password,jdbcType=VARCHAR&#125;, #&#123;phone,jdbcType=VARCHAR&#125;, #&#123;email,jdbcType=VARCHAR&#125;, #&#123;regdate,jdbcType=DATE&#125;, #&#123;sex,jdbcType=INTEGER&#125;, #&#123;head,jdbcType=VARCHAR&#125;) &lt;/insert&gt; &lt;insert id="insertSelective" parameterType="com.zjm.model.User"&gt; insert into user &lt;trim prefix="(" suffix=")" suffixOverrides=","&gt; &lt;if test="id != null"&gt; Id, &lt;/if&gt; &lt;if test="nickname != null"&gt; nickName, &lt;/if&gt; &lt;if test="password != null"&gt; password, &lt;/if&gt; &lt;if test="phone != null"&gt; phone, &lt;/if&gt; &lt;if test="email != null"&gt; email, &lt;/if&gt; &lt;if test="regdate != null"&gt; regDate, &lt;/if&gt; &lt;if test="sex != null"&gt; sex, &lt;/if&gt; &lt;if test="head != null"&gt; head, &lt;/if&gt; &lt;/trim&gt; &lt;trim prefix="values (" suffix=")" suffixOverrides=","&gt; &lt;if test="id != null"&gt; #&#123;id,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="nickname != null"&gt; #&#123;nickname,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="password != null"&gt; #&#123;password,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="phone != null"&gt; #&#123;phone,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="email != null"&gt; #&#123;email,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="regdate != null"&gt; #&#123;regdate,jdbcType=DATE&#125;, &lt;/if&gt; &lt;if test="sex != null"&gt; #&#123;sex,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="head != null"&gt; #&#123;head,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;/trim&gt; &lt;/insert&gt; &lt;update id="updateByPrimaryKeySelective" parameterType="com.zjm.model.User"&gt; update user &lt;set&gt; &lt;if test="nickname != null"&gt; nickName = #&#123;nickname,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="password != null"&gt; password = #&#123;password,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="phone != null"&gt; phone = #&#123;phone,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="email != null"&gt; email = #&#123;email,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="regdate != null"&gt; regDate = #&#123;regdate,jdbcType=DATE&#125;, &lt;/if&gt; &lt;if test="sex != null"&gt; sex = #&#123;sex,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="head != null"&gt; head = #&#123;head,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;/set&gt; where Id = #&#123;id,jdbcType=INTEGER&#125; &lt;/update&gt; &lt;update id="updateByPrimaryKey" parameterType="com.zjm.model.User"&gt; update user set nickName = #&#123;nickname,jdbcType=VARCHAR&#125;, password = #&#123;password,jdbcType=VARCHAR&#125;, phone = #&#123;phone,jdbcType=VARCHAR&#125;, email = #&#123;email,jdbcType=VARCHAR&#125;, regDate = #&#123;regdate,jdbcType=DATE&#125;, sex = #&#123;sex,jdbcType=INTEGER&#125;, head = #&#123;head,jdbcType=VARCHAR&#125; where Id = #&#123;id,jdbcType=INTEGER&#125; &lt;/update&gt;&lt;/mapper&gt; 测试类进入UserMapper.java，右键——Go to—— Test——Create new test 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.zjm.dao;import com.zjm.model.User;import com.zjm.util.MD5;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import java.util.Date;import static org.junit.Assert.*;/** * Created by ZJM on 2017/4/5. */@SpringBootTest@RunWith(SpringJUnit4ClassRunner.class)public class UserMapperTest &#123; @Autowired private UserMapper userMapper; @Test public void deleteByPrimaryKey() throws Exception &#123; userMapper.deleteByPrimaryKey(2); &#125; @Test public void insert() throws Exception &#123; User user = new User(); user.setPhone("13636662259"); user.setSex(0); user.setEmail("7788521@qq.com"); user.setNickname("zjm"); user.setPassword("123456"); user.setRegdate(new Date()); userMapper.insert(user); &#125; @Test public void insertSelective() throws Exception &#123; &#125; @Test public void selectByPrimaryKey() throws Exception &#123; User user = userMapper.selectByPrimaryKey(1); System.out.println(user); &#125; @Test public void updateByPrimaryKeySelective() throws Exception &#123; User user = new User(); user.setId(1); user.setNickname("shaunHaHaHa"); userMapper.updateByPrimaryKeySelective(user); &#125; @Test public void updateByPrimaryKey() throws Exception &#123; &#125; @Test public void selectUserByExample() throws Exception &#123; User user = new User(); user.setPassword("123456"); System.out.println(userMapper.selectUserByExample(user)); &#125;&#125; 点击方法旁边的绿色按钮运行就行了 发请求测试上面的是 JUnit 的单元测试，现在用发请求的方式从服务器获取响应 正常需要在controller和mapper中间建立service层，这里示例业务简单，简化省去了service层，正式的项目中再加上 新建controller 在com.*.controller下新建UserMS.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.zjm.controller;import com.sun.javafx.collections.MappingChange;import com.zjm.dao.UserMapper;import com.zjm.model.User;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.servlet.http.HttpServletResponse;import java.util.HashMap;import java.util.List;import java.util.Map;/** * Created by ZJM on 2017/4/8. */@RestController@RequestMapping("/user")public class UserMS &#123; @Autowired private UserMapper userMapper; @RequestMapping("add") public User add(User user) &#123; userMapper.insert(user); return user; &#125; @RequestMapping("delete") public Map&lt;String,Object&gt; delete(int id) &#123; Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;(); boolean isOk = true; try &#123; userMapper.deleteByPrimaryKey(id); &#125; catch (Exception e) &#123; e.printStackTrace(); isOk = false; &#125; map.put("status",isOk); return map; &#125; @RequestMapping("update") public User update(User user) &#123; userMapper.updateByPrimaryKeySelective(user); return user; &#125; @RequestMapping("findUserById") public User findUserById(int id) &#123; return userMapper.selectByPrimaryKey(id); &#125; @RequestMapping("findUserByExample") public List&lt;User&gt; findUserByExample(User user) &#123; return userMapper.selectUserByExample(user); &#125;&#125; 运行*Application.java文件点击绿色三角，即可启动 IntelliJ 自带的 tomcat，按照配置的服务名及端口访问吧 发请求安装postman或者浏览器发送请求 eg 1234http://localhost:8080/user/findUserById?id=1http://localhost:8080/user/findUserByExample?sex=1http://localhost:8080/user/delete?id=5http://localhost:8080/user/update?id=6&amp;nickname=小王 要是用浏览器发post请求还得写表单，post请求就用 postman 发吧 到此一个简单的例子就可以运行了]]></content>
      <categories>
        <category>Project</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>IntelliJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos下安装jdk和Tomcat]]></title>
    <url>%2F2017%2F03%2F05%2Finstall-jdk-tomcat%2F</url>
    <content type="text"><![CDATA[用yum安装jdk查看 yum 库中都有哪些 jdk 版本（暂时只发现了 openjdk）yum search java|grep jdk 安装yum install java-1.7.0-openjdk 设置环境变量在profile文件中添加如下内容： 1234567#set java environmentJAVA_HOME=/usr/lib/jvm/java-1.7.0-openjdk-1.7.0.131#复制路径以防路径无法找到JRE_HOME=$JAVA_HOME/jreCLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/libPATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/binexport JAVA_HOME JRE_HOME CLASS_PATH PATH 让修改生效 source /etc/profile 验证java -version 安装Tomcat使用wget命令：wget -c http://apache.fayea.com/tomcat/tomcat-8/v8.5.11/bin/apache-tomcat-8.5.11.tar.gz 解压tar -zxvf apache-tomcat-8.5.11.tar.gz 启动进入解压后的apache-tomcat-8.5.11 -- bin目录，执行命令： ./startup.sh 检查能否访问如果不能访问，可能是防火墙问题： 关闭防火墙： service firewalld stop 在iptables里添加开放 8080 端口： -A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT 将iptables服务重启： service iptables restart]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos下安装mysql]]></title>
    <url>%2F2017%2F03%2F05%2Finstall-mysql%2F</url>
    <content type="text"><![CDATA[yum 安装yum install -y mysql-server mysql mysql-devel 启动服务service mysqld start 给root用户设置密码mysqladmin -u root password &#39;your password&#39; 登录mysql -u root -p 查看并更改字符集show variables like &#39;character%&#39;; 关闭mysql服务 service mysqld stop 修改my.cnf文件 12345678910111213141516171819202122[mysqld]default-character-set = utf8 #这个是我添加的character_set_server=utf8 #这个是我添加的init_connect='SET NAMES utf8'datadir=/var/lib/mysqlsocket=/var/lib/mysql/mysql.sockuser=mysqlsymbolic-links=0 [mysqld_safe]default-character-set = utf8 #这个是我添加的log-error=/var/log/mysqld.logpid-file=/var/run/mysqld/mysqld.pid [client]default-character-set = utf8 #这个是我添加的 [mysql.server]default-character-set = utf8 #这个是我添加的 [mysql]default-character-set = utf8 #这个是我添加的 重启服务service mysqld restart 查看监听端口netstat -anp mysql数据库绑定的默认端口号是 3306 用本地可视化工具连接服务器数据库在服务器端进入mysql服务，执行： 12grant all privileges on *.* to &apos;root&apos;@&apos;%&apos; identified by &apos;your password by root&apos;;flush privileges; 在本地即可登录访问]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[priority_queue]]></title>
    <url>%2F2017%2F02%2F06%2Fpriority-queue%2F</url>
    <content type="text"><![CDATA[STL priority_queue 优先队列在优先队列中，优先级高的元素先出队列 class template std::priority_queue1234template &lt;class T, class Container = vector&lt;T&gt;, class Compare = less&lt;typename Container::value_type&gt; &gt; class priority_queue; Priority queuePriority queues are a type of container adaptors, specifically designed such that its first element is always the greatest of the elements it contains, according to some strict weak ordering criterion.This context is similar to a heap, where elements can be inserted at any moment, and only the max heapelement can be retrieved (the one at the top in the priority queue).Priority queues are implemented as container adaptors, which are classes that use an encapsulated object of a specific container class as its underlying container, providing a specific set of member functions to access its elements. Elements are popped from the “back” of the specific container, which is known as the top of the priority queue. The standard container classes vector and deque fulfill these requirements. By default, if no container class is specified for a particular priority_queue class instantiation, the standard container vector is used.Support of random access iterators is required to keep a heap structure internally at all times. This is done automatically by the container adaptor by automatically calling the algorithm functions make_heap, push_heap and pop_heap when needed. Template parameters T Type of the elements.Aliased as member type priority_queue::value_type. Container Type of the internal underlying container object where the elements are stored.Its value_type shall be T.Aliased as member type priority_queue::container_type. Compare A binary predicate that takes two elements (of type T) as arguments and returns a bool.The expression comp(a,b), where comp is an object of this type and a and b are elements in the container, shall return true if a is considered to go before b in the strict weak ordering the function defines.The priority_queue uses this function to maintain the elements sorted in a way that preserves heap properties (i.e., that the element popped is the last according to this strict weak ordering).This can be a function pointer or a function object, and defaults to less, which returns the same as applying the less-than operator (`a). 小结： priority_queue 将其中的元素默认按照从大到小排列 默认声明：priority_queue&lt; T , vector , less &gt; q; 默认声明可省略为：priority_queue q; 声明为从小到大：priority_queue&lt; T , vector , greater &gt; q; 如果T是自定义类型，则必须重载operator&lt; eg123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;struct Student &#123; string name; int score; Student(string name,int score) &#123; this-&gt;name = name; this-&gt;score = score; &#125; friend bool operator &lt; (Student stu1,Student stu2) &#123; return stu1.score &lt; stu2.score; &#125;&#125;;int main()&#123; Student stu[3] = &#123; Student("Tom",80), Student("Jerry",100), Student("Marry",90) &#125;; priority_queue&lt;Student&gt; q; for(int i=0;i&lt;3;i++) &#123; q.push(stu[i]); &#125; cout&lt;&lt;q.size()&lt;&lt;endl; for(int i=0;i&lt;3;i++) &#123; Student s = q.top(); cout&lt;&lt;s.name&lt;&lt;", "&lt;&lt;s.score&lt;&lt;endl; q.pop(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OJ 做题</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Share~]]></title>
    <url>%2F2017%2F01%2F24%2Fky%2F</url>
    <content type="text"><![CDATA[分享给朋友的Dear Mao Shuo: 你看历年分数线先给自己各科定个小目标，100+100+50+50啊，关注几个老师的微博，微信公众号：蒋中挺，何凯文，张宇，刘一男……都会有免费的直播，何凯文还有每日一句，有时间就看，没时间就算了别当负担，我每日一句就跟了一阵。直播课感觉蒋中挺的挺好的，还有回放，英语数学我都没咋听，不过我还是推荐听。我学的时间里有效的部分太少了：早上九点开始，两个半小时去吃饭，中午ZZZ，下午两点开始，三个小时又吃饭，晚上六点开始，四个小时回寝，一天最多十个小时的学习时间，真正有收获的没多少。。。我九月份还报了文都的秋季班（补暑假课程的班），因为我暑假有实训。文都的课好也不好，为了赶进度，有时一天看十个多小时的视频。往往一天下来很累了，回来就没有把一天的课进行总结整理笔记。我有一次整理了一次，花了很多时间，因为课上的内容太多，老师说的很快，好多听不懂的需要课后自己整理复习，如果没有总结复习，那课久了回看笔记就看不懂了，还会越堆越多。所以，不及时总结复习，课就等于白上，还浪费大量的时间和精力。 其实还是自己总结最重要了，看视频，做题，再多，自己不理解归纳总结知识点，意义都不大。做题我有一招特别好使，如果你知道这道题考的考点是什么，你一定能做对。所以，数学背笔记时一定要背考点，12345… 复习计划早制定，专业课早开始，政治选择早开始，真的不是很难，别害怕，就是路漫漫修远，坚持下来不容易。 如果我调剂不到好的学校，就做研友；复试通过，就给你书… Good luck Shaun]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法小结]]></title>
    <url>%2F2017%2F01%2F23%2Fsort%2F</url>
    <content type="text"><![CDATA[数据结构排序算法时空稳 分类 排序方法 平均情况(时) 最坏(时) 最好(时) 空间复杂度 稳定性 插入 直接插入 O(n*n) O(n*n) O(n) O(1) 稳 折半插入 O(n*n) O(1) 稳 希尔 O(nlogn) O(nlogn) O(1) 不稳 交换 冒泡 O(n*n) O(n*n) O(n) O(1) 稳 快速 O(nlogn) O(n*n) O(nlogn) O(logn) 不稳 选择 简单选择 O(n*n) O(n*n) O(n*n) O(1) 不稳 堆排 O(nlogn) O(nlogn) O(nlogn) O(1) 不稳 其他 归并 O(nlogn) O(nlogn) O(nlogn) O(n) 稳 基数 O(d(n+r)) O(d(n+r)) O(d(n+r)) O(r) 稳 常见排序java实现直接插入1234567891011121314public class InsertSort &#123; public static void isort(int[] data) &#123; for (int i=1; i&lt;data.length; i++) &#123; int temp = data[i]; int j = i-1; while (j &gt;=0 &amp;&amp; temp &lt; data[j]) &#123; data[j+1] = data[j--]; &#125; data[j+1] = temp; &#125; &#125; &#125; 选择12345678910111213141516171819public class SelectSort &#123; // 找到待排序中最小或者最大 public static void s_sort(int[] data) &#123; for (int i=0; i&lt;data.length-1; i++) &#123; int k = i; // 记录待排序中最小下标 for (int j=i+1; j&lt;data.length; j++) &#123; if (data[j] &lt; data[k]) &#123; k = j; &#125; &#125; // 将最小放到最前面 if (k != i) &#123; int temp = data[k]; data[k] = data[i]; data[i] = temp; &#125; &#125; &#125;&#125; 快排1234567891011121314151617181920212223242526272829303132333435public class QuickSort &#123; private static int[] arr; // 讲一个数字放到正确的位置，左边都比它小，右边都比它大 private static int partition(int low, int high) &#123; int label = arr[low]; while (low &lt; high) &#123; while (low &lt; high &amp;&amp; arr[high] &gt;= label) high --; arr[low] = arr[high]; while (low &lt; high &amp;&amp; arr[low] &lt;= label) low ++; arr[high] = arr[low]; &#125; arr[low] = label; return low; &#125; private static int[] qsort(int low, int high) &#123; if (low &lt; high) &#123; int mid = partition(low, high); qsort(low, mid-1); qsort(mid+1, high); &#125; return arr; &#125; public static int[] qsort(int[] data) &#123; arr = data; qsort(0, arr.length-1); return arr; &#125; &#125; 冒泡12345678910111213141516public class BubbleSort &#123; public static void bsort(int[] arr) &#123; int temp = 0; for (int i=0; i&lt;arr.length-1; i++) &#123; for (int j=arr.length-1; j&gt;i; j--) &#123; // 将小的前移 if (arr[j] &lt; arr[j-1]) &#123; temp = arr[j]; arr[j] = arr[j-1]; arr[j-1] = temp; &#125; &#125; &#125; &#125;&#125; 堆排归并1234567891011121314151617181920212223242526272829303132333435363738394041public class MergeSort &#123; private static int[] data; public static void sort(int[] arr) &#123; data = arr; mergeSort(1, data.length); &#125; private static void mergeSort(int start, int end) &#123; if (end &gt; start) &#123; int mid = (start + end) / 2; mergeSort(start, mid); mergeSort(mid+1, end); merge(start, mid, end); &#125; &#125; private static void merge(int start, int mid, int end) &#123; int len1 = mid - start + 1; int len2 = end - mid; int[] arr1 = new int[len1 + 1]; int[] arr2 = new int[len2 + 1]; for (int i=0; i&lt;len1; i++) &#123; arr1[i] = data[start+i-1]; &#125; arr1[len1] = Integer.MAX_VALUE; for (int i=0; i&lt;len2; i++) &#123; arr2[i] = data[i+mid]; &#125; arr2[len2] = Integer.MAX_VALUE; int m = 0, n = 0; for (int i=start-1; i&lt;end; i++) &#123; if (arr1[m] &gt; arr2[n]) &#123; data[i] = arr2[n++]; &#125; else &#123; data[i] = arr1[m++]; &#125; &#125; &#125;&#125; 希尔12345678910111213141516171819public class ShellSort &#123; public static void sort(int[] arr) &#123; for (int gap=arr.length/2; gap&gt;0; gap/=2) &#123; for (int i=gap; i&lt;arr.length; i++) &#123; int j = i; int temp = arr[j]; if (arr[j] &lt; arr[j-gap]) &#123; while (j-gap&gt;=0 &amp;&amp; temp &lt; arr[j-gap]) &#123; arr[j] = arr[j-gap]; j-=gap; &#125; arr[j] = temp; &#125; &#125; &#125; &#125; &#125; 计数桶排基数小口诀 冒泡选择插入堆，快速希尔计基堆归并O(n)快logn，其他空间都是1快堆归并nlogn，插折冒选慢n方（平均时间）希尔特殊1.3，基数d把两数加（平均时间）希尔快选堆不稳，其他排序稳稳哒 注： log 的 g 不发音 第二句空间复杂度，三四句时间]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git基本操作]]></title>
    <url>%2F2017%2F01%2F15%2FGit%2F</url>
    <content type="text"><![CDATA[Git 是目前最流行的版本管理系统 Windows系统安装和使用安装后会出现三个工具-Bash,-CMD,-GUI，只用-Bash就行 在你想作为本地仓库的文件夹上（或进入文件夹空白处）鼠标右键，选择Git Bash here 常用命令git clone​ 从远程主机复制文件到本地文件夹 1$ git clone &lt;链接&gt; &lt;本地路径&gt; ​ &lt;本地路径&gt;省略即-Bash当前路径 git remote 管理远程主机名：Git要求每个远程主机都必须指定一个主机名 添加远程主机+命名 1$ git remote add &lt;主机名&gt; &lt;网址&gt; 列出所有远程主机 12$ git remoteorigin 查看远程主机名对应的网址 123$ git remote -vorigin https://... (fetch)origin https://...(push) 删除主机 1$ git remote rm &lt;主机名&gt; 改主机名 1$ git remote rename &lt;原主机名&gt; &lt;新主机名&gt; git fetch 远程主机有更新（commit），将更新的取回本地。默认情况下git fetch 取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名。 1$ git fetch &lt;远程主机名&gt; &lt;分支名&gt; eg 1$ git fetch origin master 查看远程分支 123456$ git branch -rorigin/master #查看远程分支$ git branch -a #查看所有分支（包括本地）* master remotes/origin/master 在本地分支上合并远程分支 1$ git merge origin/master git pull 取回远程主机某分支的更新，并与本地的制定分支合并 1$ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 与当前分支合并冒号后可省略 eg 1$ git pull origin master 相当于 12$ git fetch origin$ git merge origin/master git push 将本地分支的更新，推送到远程主机 1$ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; eg 123$ git push origin master:master#等同于$ git push origin master 如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。 上面命令表示，将本地的master分支推送到origin主机的master分支。 省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支 123$ git push origin :master# 等同于$ git push origin --delete master 上面命令表示删除origin主机的master分支 更详细资料请参照：https://www.git-scm.com/book/en/v2]]></content>
      <categories>
        <category>版本控制</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开篇]]></title>
    <url>%2F2017%2F01%2F13%2FBegin%2F</url>
    <content type="text"><![CDATA[自序​ 大家好，我是一个普通的大学生，2013年考入哈尔滨工程大学软件工程专业，2017年想写博客，已经24岁。人生正在紧要关口，大的决策呼之欲出。 ​ 现在的我，放假在家，感到有属于自己的时间无比宝贵，没有外事打扰，想干什么就干什么，以后怕是少有了，无比珍惜。每天能做自己喜欢做的事，玩也好，学也好，不必担心衣食住行，真是最后的天堂了。 ​ 想把自己的收获、乐趣、心得，想法通过网站向有缘来访的朋友分享，留住生命中的点滴。 ​ 这两天为了建一个博客站，忙来忙去找了很多资料，问了很多朋友。总算有了点成果，虽然就是读说明书，还是很费劲，遇到的问题层出不穷……我觉的程序员最宝贵的能力就是自学能力，敢于接触新鲜事物，读懂别人的文章，英文开发文档，自己把新技术掌握了，并有自己的理解。 ​ 现在的我还差很多，希望在朋友的帮助下，师长的指导下，一点一点的，不断进步。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
</search>
